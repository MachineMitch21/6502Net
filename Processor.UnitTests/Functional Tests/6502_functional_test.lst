AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

5801 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2013  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 16-aug-2013
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0000 =                  load_data_direct = 0
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $5B (91) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
                        ;parts of the code are self modifying and must reside in RAM
0400 =                  code_segment = $400  
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    php         ;use stack to retrieve status
                                    pla
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    php
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    php
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    php
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                    sta range_adr   ;reset self modifying code
                                    sta tandi1
                                    sta tandi2
                                    sta teori1
                                    sta teori2
                                    sta torai1
                                    sta torai2
                                    sta chkdadi  
                                    sta chkdsbi
                                    sta chkadi
                                    sta chksbi
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(data_segment) ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(data_bss) ;data after write test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
000a =                          org zero_page
                        ;break test interrupt save
000a =                  irq_a   ds  1               ;a register
000b =                  irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c =                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c =                  adfc    ds  1               ;carry flag before op
000d =                  ad1     ds  1               ;operand 1 - accumulator
000e =                  ad2     ds  1               ;operand 2 - memory / immediate
000f =                  adrl    ds  1               ;expected result bits 0-7
0010 =                  adrh    ds  1               ;expected result bit 8 (carry)
0011 =                  adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0012 =                  sb2     ds  1               ;operand 2 complemented for subtract
0013 =                  zp_bss
0013 =                  zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0017 =                  zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0018 =                  zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001c =                  zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0020 =                  zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0024 =                  ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0026 =                          dw  abs1+1
0028 =                          dw  abs1+2
002a =                          dw  abs1+3
002c =                          dw  abs7f
002e =                  inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0030 =                  indt    dw  abst            ;indirect pointer to store area in absolute memory
0032 =                          dw  abst+1
0034 =                          dw  abst+2
0036 =                          dw  abst+3
0038 =                  inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003a =                  indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003c =                          dw  absAN+1
003e =                          dw  absAN+2
0040 =                          dw  absAN+3
0042 =                  indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0044 =                          dw  absEO+1
0046 =                          dw  absEO+2
0048 =                          dw  absEO+3
004a =                  indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004c =                          dw  absOR+1
004e =                          dw  absOR+2
0050 =                          dw  absOR+3
                        ;add/subtract indirect pointers
0052 =                  adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0054 =                  sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0056 =                  adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0058 =                  sbiy2   dw  sba2-$ff
005a =                  zp_bss_end
                           
0200 =                          org data_segment
0200 =                  test_case   ds  1           ;current test number
0201 =                  ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 =                  abst                        ;5 bytes store/modify test area
0203 =                  ada2    ds  1               ;operand 2
0204 =                  sba2    ds  1               ;operand 2 complemented for subtract
0205 =                          ds  3               ;fill remaining bytes
0208 =                  data_bss
0208 =                  abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
020c =                  abs7f   db  $7f             ;test pattern for compare
                        ;loads
020d =                  fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0211 =                  rASL                        ;expected result ASL & ROL -carry  
0211 =                  rROL    db  $86,$04,$82,0   ; "
0215 =                  rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0219 =                  rLSR                        ;expected result LSR & ROR -carry
0219 =                  rROR    db  $61,$41,$20,0   ; "
021d =                  rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0221 =                  fASL                        ;expected flags for shifts
0221 =                  fROL    db  fnc,fc,fn,fz    ;no carry in
0225 =                  fROLc   db  fnc,fc,fn,0     ;carry in
0229 =                  fLSR
0229 =                  fROR    db  fc,0,fc,fz      ;no carry in
022d =                  fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0231 =                  rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0236 =                  fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
023b =                  absOR   db  0,$1f,$71,$80   ;test pattern for OR
023f =                  absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0243 =                  absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0247 =                  absORa  db  0,$f1,$1f,0     ;test pattern for OR
024b =                  absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
024f =                  absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0253 =                  absrlo  db  0,$ff,$7f,$80
0257 =                  absflo  db  fz,fn,0,fn
025b =                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;initialize BSS segment
                            if load_data_direct != 1
0409 : a246                     ldx #zp_end-zp_init-1
040b : bd2e37           ld_zp   lda zp_init,x
040e : 9513                     sta zp_bss,x
0410 : ca                       dex
0411 : 10f8                     bpl ld_zp
0413 : a252                     ldx #data_end-data_init-1
0415 : bd7537           ld_data lda data_init,x
0418 : 9d0802                   sta data_bss,x
041b : ca                       dex
041c : 10f7                     bpl ld_data
                              if ROM_vectors = 1
041e : a205                     ldx #5
0420 : bdc837           ld_vect lda vec_init,x
0423 : 9dfaff                   sta vec_bss,x
0426 : ca                       dex
0427 : 10f7                     bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                                sta range_adr   ;reset self modifying code
                                sta tandi1
                                sta tandi2
                                sta teori1
                                sta teori2
                                sta torai1
                                sta torai2
                                sta chkdadi  
                                sta chkdsbi
                                sta chkadi
                                sta chksbi
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(data_segment) ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(data_bss) ;data after write test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0429 : ad0002          >            lda test_case   ;previous test
042c : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
042e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
0430 : a901            >            lda #test_num   ;*** next tests' number
0432 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing relative addressing with BEQ
0435 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0437 :                  range_loop
0437 : 88                       dey             ;next relative address
0438 : 98                       tya
0439 : aa                       tax             ;precharge count to end of loop
043a : 1003                     bpl range_fw    ;calculate relative address
043c : 18                       clc             ;avoid branch self or to relative address of branch
043d : 6902                     adc #2
043f :                  range_fw
043f : 497f                     eor #$7f        ;complement except sign
0441 : 8dc804                   sta range_adr   ;load into test target
0444 : a900                     lda #0          ;should set zero flag in status register
0446 : 4cc704                   jmp range_op
                                
                                ;relative address target field with branch under test in the middle                       
0449 : ca                       dex             ;-128 - max backward
044a : ca                       dex
044b : ca                       dex
044c : ca                       dex
044d : ca                       dex
044e : ca                       dex
044f : ca                       dex
0450 : ca                       dex
0451 : ca                       dex             ;-120
0452 : ca                       dex
0453 : ca                       dex
0454 : ca                       dex
0455 : ca                       dex
0456 : ca                       dex
0457 : ca                       dex
0458 : ca                       dex
0459 : ca                       dex
045a : ca                       dex
045b : ca                       dex             ;-110
045c : ca                       dex
045d : ca                       dex
045e : ca                       dex
045f : ca                       dex
0460 : ca                       dex
0461 : ca                       dex
0462 : ca                       dex
0463 : ca                       dex
0464 : ca                       dex
0465 : ca                       dex             ;-100
0466 : ca                       dex
0467 : ca                       dex
0468 : ca                       dex
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex
046e : ca                       dex
046f : ca                       dex             ;-90
0470 : ca                       dex
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex
0478 : ca                       dex
0479 : ca                       dex             ;-80
047a : ca                       dex
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex
0482 : ca                       dex
0483 : ca                       dex             ;-70
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex             ;-60
048e : ca                       dex
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex             ;-50
0498 : ca                       dex
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex             ;-40
04a2 : ca                       dex
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex             ;-30
04ac : ca                       dex
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex             ;-20
04b6 : ca                       dex
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex             ;-10
04c0 : ca                       dex
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex             ;-3
04c7 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04c8 =                  range_adr   = *+1       ;modifiable relative address
04c7 : f03e                     beq *+64        ;if called without modification
04c9 : ca                       dex             ;+0
04ca : ca                       dex
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex             ;+10
04d4 : ca                       dex
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex             ;+20
04de : ca                       dex
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex
04e5 : ca                       dex
04e6 : ca                       dex
04e7 : ca                       dex             ;+30
04e8 : ca                       dex
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex             ;+40
04f2 : ca                       dex
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex             ;+50
04fc : ca                       dex
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex             ;+60
0506 : ca                       dex
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex             ;+70
0510 : ca                       dex
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex             ;+80
051a : ca                       dex
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex             ;+90
0524 : ca                       dex
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex             ;+100
052e : ca                       dex
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex             ;+110
0538 : ca                       dex
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex             ;+120
0542 : ca                       dex
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : f004                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
054a : 4c4a05          >        jmp *           ;failed anyway
                        
054d : ca               		dex
054e :                  range_ok
054e : c000                     cpy #0
0550 : f003                     beq range_end   
0552 : 4c3704                   jmp range_loop
0555 :                  range_end               ;range test successful
                                next_test
0555 : ad0002          >            lda test_case   ;previous test
0558 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
055a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
055c : a902            >            lda #test_num   ;*** next tests' number
055e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
0561 : c001                     cpy #1          ;testing BNE true
0563 : d003                     bne test_bne
                                trap 
0565 : 4c6505          >        jmp *           ;failed anyway
                        
0568 :                  test_bne
0568 : a900                     lda #0 
056a : c900                     cmp #0          ;test compare immediate 
                                trap_ne
056c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
056e : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0570 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
0572 : c901                     cmp #1
                                trap_eq 
0574 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0576 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0578 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
057a : aa                       tax 
057b : e000                     cpx #0          ;test compare x immediate
                                trap_ne
057d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
057f : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0581 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
0583 : e001                     cpx #1
                                trap_eq 
0585 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0587 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0589 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
058b : a8                       tay 
058c : c000                     cpy #0          ;test compare y immediate
                                trap_ne
058e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
0590 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0592 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
0594 : c001                     cpy #1
                                trap_eq 
0596 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0598 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
059a : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
059c : ad0002          >            lda test_case   ;previous test
059f : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05a3 : a903            >            lda #test_num   ;*** next tests' number
05a5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05a8 : a2ff                     ldx #$ff        ;initialize stack
05aa : 9a                       txs
05ab : a955                     lda #$55
05ad : 48                       pha
05ae : a9aa                     lda #$aa
05b0 : 48                       pha
05b1 : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
05b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05b6 : ba                       tsx
05b7 : 8a                       txa             ;overwrite accu
05b8 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
05ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
05bc : 68                       pla
05bd : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
05bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
05c1 : 68                       pla
05c2 : c955                     cmp #$55
                                trap_ne
05c4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05c6 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05cb : ba                       tsx
05cc : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05d0 : ad0002          >            lda test_case   ;previous test
05d3 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
05d7 : a904            >            lda #test_num   ;*** next tests' number
05d9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
05dc : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
05de : 48              >            pha         ;use stack to load status
05df : 28              >            plp
                        
05e0 : 101a                     bpl nbr1        ;branches should not be taken
05e2 : 501b                     bvc nbr2
05e4 : 901c                     bcc nbr3
05e6 : d01d                     bne nbr4
05e8 : 3003                     bmi br1         ;branches should be taken
                                trap 
05ea : 4cea05          >        jmp *           ;failed anyway
                        
05ed : 7003             br1     bvs br2
                                trap 
05ef : 4cef05          >        jmp *           ;failed anyway
                        
05f2 : b003             br2     bcs br3
                                trap 
05f4 : 4cf405          >        jmp *           ;failed anyway
                        
05f7 : f00f             br3     beq br4
                                trap 
05f9 : 4cf905          >        jmp *           ;failed anyway
                        
05fc :                  nbr1
                                trap            ;previous bpl taken 
05fc : 4cfc05          >        jmp *           ;failed anyway
                        
05ff :                  nbr2
                                trap            ;previous bvc taken
05ff : 4cff05          >        jmp *           ;failed anyway
                        
0602 :                  nbr3
                                trap            ;previous bcc taken
0602 : 4c0206          >        jmp *           ;failed anyway
                        
0605 :                  nbr4
                                trap            ;previous bne taken
0605 : 4c0506          >        jmp *           ;failed anyway
                        
0608 : 08               br4     php
0609 : ba                       tsx
060a : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
060c : d0fe            >        bne *           ;failed not equal (non zero)
                        
060e : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
060f : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0611 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0613 : ba                       tsx
0614 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0616 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0618 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
061a : 48              >            pha         ;use stack to load status
061b : 28              >            plp
                        
061c : 301a                     bmi nbr11       ;branches should not be taken
061e : 701b                     bvs nbr12
0620 : b01c                     bcs nbr13
0622 : f01d                     beq nbr14
0624 : 1003                     bpl br11        ;branches should be taken
                                trap 
0626 : 4c2606          >        jmp *           ;failed anyway
                        
0629 : 5003             br11    bvc br12
                                trap 
062b : 4c2b06          >        jmp *           ;failed anyway
                        
062e : 9003             br12    bcc br13
                                trap 
0630 : 4c3006          >        jmp *           ;failed anyway
                        
0633 : d00f             br13    bne br14
                                trap 
0635 : 4c3506          >        jmp *           ;failed anyway
                        
0638 :                  nbr11
                                trap            ;previous bmi taken 
0638 : 4c3806          >        jmp *           ;failed anyway
                        
063b :                  nbr12
                                trap            ;previous bvs taken 
063b : 4c3b06          >        jmp *           ;failed anyway
                        
063e :                  nbr13
                                trap            ;previous bcs taken 
063e : 4c3e06          >        jmp *           ;failed anyway
                        
0641 :                  nbr14
                                trap            ;previous beq taken 
0641 : 4c4106          >        jmp *           ;failed anyway
                        
0644 : 08               br14    php
0645 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0646 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0648 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
064a : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
064c : 48              >            pha         ;use stack to load status
064d : 28              >            plp
                        
064e : d002                     bne brzs1
0650 : f003                     beq brzs2
0652 :                  brzs1
                                trap            ;branch zero/non zero
0652 : 4c5206          >        jmp *           ;failed anyway
                        
0655 : b002             brzs2   bcs brzs3
0657 : 9003                     bcc brzs4
0659 :                  brzs3
                                trap            ;branch carry/no carry
0659 : 4c5906          >        jmp *           ;failed anyway
                        
065c : 3002             brzs4   bmi brzs5
065e : 1003                     bpl brzs6
0660 :                  brzs5
                                trap            ;branch minus/plus
0660 : 4c6006          >        jmp *           ;failed anyway
                        
0663 : 7002             brzs6   bvs brzs7
0665 : 5003                     bvc brzs8
0667 :                  brzs7
                                trap            ;branch overflow/no overflow
0667 : 4c6706          >        jmp *           ;failed anyway
                        
066a :                  brzs8
                                set_stat carry
                       >            load_flag carry
066a : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
066c : 48              >            pha         ;use stack to load status
066d : 28              >            plp
                        
066e : f002                     beq brcs1
0670 : d003                     bne brcs2
0672 :                  brcs1
                                trap            ;branch zero/non zero
0672 : 4c7206          >        jmp *           ;failed anyway
                        
0675 : 9002             brcs2   bcc brcs3
0677 : b003                     bcs brcs4
0679 :                  brcs3
                                trap            ;branch carry/no carry
0679 : 4c7906          >        jmp *           ;failed anyway
                        
067c : 3002             brcs4   bmi brcs5
067e : 1003                     bpl brcs6
0680 :                  brcs5
                                trap            ;branch minus/plus
0680 : 4c8006          >        jmp *           ;failed anyway
                        
0683 : 7002             brcs6   bvs brcs7
0685 : 5003                     bvc brcs8
0687 :                  brcs7
                                trap            ;branch overflow/no overflow
0687 : 4c8706          >        jmp *           ;failed anyway
                        
                        
068a :                  brcs8
                                set_stat minus
                       >            load_flag minus
068a : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
068c : 48              >            pha         ;use stack to load status
068d : 28              >            plp
                        
068e : f002                     beq brmi1
0690 : d003                     bne brmi2
0692 :                  brmi1
                                trap            ;branch zero/non zero
0692 : 4c9206          >        jmp *           ;failed anyway
                        
0695 : b002             brmi2   bcs brmi3
0697 : 9003                     bcc brmi4
0699 :                  brmi3
                                trap            ;branch carry/no carry
0699 : 4c9906          >        jmp *           ;failed anyway
                        
069c : 1002             brmi4   bpl brmi5
069e : 3003                     bmi brmi6
06a0 :                  brmi5
                                trap            ;branch minus/plus
06a0 : 4ca006          >        jmp *           ;failed anyway
                        
06a3 : 7002             brmi6   bvs brmi7
06a5 : 5003                     bvc brmi8
06a7 :                  brmi7
                                trap            ;branch overflow/no overflow
06a7 : 4ca706          >        jmp *           ;failed anyway
                        
06aa :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06aa : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
06ac : 48              >            pha         ;use stack to load status
06ad : 28              >            plp
                        
06ae : f002                     beq brvs1
06b0 : d003                     bne brvs2
06b2 :                  brvs1
                                trap            ;branch zero/non zero
06b2 : 4cb206          >        jmp *           ;failed anyway
                        
06b5 : b002             brvs2   bcs brvs3
06b7 : 9003                     bcc brvs4
06b9 :                  brvs3
                                trap            ;branch carry/no carry
06b9 : 4cb906          >        jmp *           ;failed anyway
                        
06bc : 3002             brvs4   bmi brvs5
06be : 1003                     bpl brvs6
06c0 :                  brvs5
                                trap            ;branch minus/plus
06c0 : 4cc006          >        jmp *           ;failed anyway
                        
06c3 : 5002             brvs6   bvc brvs7
06c5 : 7003                     bvs brvs8
06c7 :                  brvs7
                                trap            ;branch overflow/no overflow
06c7 : 4cc706          >        jmp *           ;failed anyway
                        
06ca :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06ca : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
06cc : 48              >            pha         ;use stack to load status
06cd : 28              >            plp
                        
06ce : f002                     beq brzc1
06d0 : d003                     bne brzc2
06d2 :                  brzc1
                                trap            ;branch zero/non zero
06d2 : 4cd206          >        jmp *           ;failed anyway
                        
06d5 : 9002             brzc2   bcc brzc3
06d7 : b003                     bcs brzc4
06d9 :                  brzc3
                                trap            ;branch carry/no carry
06d9 : 4cd906          >        jmp *           ;failed anyway
                        
06dc : 1002             brzc4   bpl brzc5
06de : 3003                     bmi brzc6
06e0 :                  brzc5
                                trap            ;branch minus/plus
06e0 : 4ce006          >        jmp *           ;failed anyway
                        
06e3 : 5002             brzc6   bvc brzc7
06e5 : 7003                     bvs brzc8
06e7 :                  brzc7
                                trap            ;branch overflow/no overflow
06e7 : 4ce706          >        jmp *           ;failed anyway
                        
06ea :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
06ea : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
06ec : 48              >            pha         ;use stack to load status
06ed : 28              >            plp
                        
06ee : d002                     bne brcc1
06f0 : f003                     beq brcc2
06f2 :                  brcc1
                                trap            ;branch zero/non zero
06f2 : 4cf206          >        jmp *           ;failed anyway
                        
06f5 : b002             brcc2   bcs brcc3
06f7 : 9003                     bcc brcc4
06f9 :                  brcc3
                                trap            ;branch carry/no carry
06f9 : 4cf906          >        jmp *           ;failed anyway
                        
06fc : 1002             brcc4   bpl brcc5
06fe : 3003                     bmi brcc6
0700 :                  brcc5
                                trap            ;branch minus/plus
0700 : 4c0007          >        jmp *           ;failed anyway
                        
0703 : 5002             brcc6   bvc brcc7
0705 : 7003                     bvs brcc8
0707 :                  brcc7
                                trap            ;branch overflow/no overflow
0707 : 4c0707          >        jmp *           ;failed anyway
                        
070a :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
070a : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
070c : 48              >            pha         ;use stack to load status
070d : 28              >            plp
                        
070e : d002                     bne brpl1
0710 : f003                     beq brpl2
0712 :                  brpl1
                                trap            ;branch zero/non zero
0712 : 4c1207          >        jmp *           ;failed anyway
                        
0715 : 9002             brpl2   bcc brpl3
0717 : b003                     bcs brpl4
0719 :                  brpl3
                                trap            ;branch carry/no carry
0719 : 4c1907          >        jmp *           ;failed anyway
                        
071c : 3002             brpl4   bmi brpl5
071e : 1003                     bpl brpl6
0720 :                  brpl5
                                trap            ;branch minus/plus
0720 : 4c2007          >        jmp *           ;failed anyway
                        
0723 : 5002             brpl6   bvc brpl7
0725 : 7003                     bvs brpl8
0727 :                  brpl7
                                trap            ;branch overflow/no overflow
0727 : 4c2707          >        jmp *           ;failed anyway
                        
072a :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
072a : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
072c : 48              >            pha         ;use stack to load status
072d : 28              >            plp
                        
072e : d002                     bne brvc1
0730 : f003                     beq brvc2
0732 :                  brvc1
                                trap            ;branch zero/non zero
0732 : 4c3207          >        jmp *           ;failed anyway
                        
0735 : 9002             brvc2   bcc brvc3
0737 : b003                     bcs brvc4
0739 :                  brvc3
                                trap            ;branch carry/no carry
0739 : 4c3907          >        jmp *           ;failed anyway
                        
073c : 1002             brvc4   bpl brvc5
073e : 3003                     bmi brvc6
0740 :                  brvc5
                                trap            ;branch minus/plus
0740 : 4c4007          >        jmp *           ;failed anyway
                        
0743 : 7002             brvc6   bvs brvc7
0745 : 5003                     bvc brvc8
0747 :                  brvc7
                                trap            ;branch overflow/no overflow
0747 : 4c4707          >        jmp *           ;failed anyway
                        
074a :                  brvc8
                                next_test
074a : ad0002          >            lda test_case   ;previous test
074d : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
074f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
0751 : a905            >            lda #test_num   ;*** next tests' number
0753 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0756 : a255                     ldx #$55        ;x & y protected
0758 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
075a : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
075c : 48              >            pha         ;use stack to load status
075d : a901            >            lda #1     ;precharge accu
075f : 28              >            plp
                        
0760 : 48                       pha
                                tst_a 1,$ff
0761 : 08              >            php         ;save flags
0762 : 08              >            php
0763 : c901            >            cmp #1     ;test result
                       >            trap_ne
0765 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0767 : 68              >            pla         ;load status
                       >            cmp_flag $ff
0768 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
076a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
076c : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
076d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
076f : 48              >            pha         ;use stack to load status
0770 : a900            >            lda #0     ;precharge accu
0772 : 28              >            plp
                        
0773 : 48                       pha
                                tst_a 0,0
0774 : 08              >            php         ;save flags
0775 : 08              >            php
0776 : c900            >            cmp #0     ;test result
                       >            trap_ne
0778 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
077a : 68              >            pla         ;load status
                       >            cmp_flag 0
077b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
077d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
077f : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0780 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0782 : 48              >            pha         ;use stack to load status
0783 : a9ff            >            lda #$ff     ;precharge accu
0785 : 28              >            plp
                        
0786 : 48                       pha
                                tst_a $ff,$ff
0787 : 08              >            php         ;save flags
0788 : 08              >            php
0789 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
078b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
078d : 68              >            pla         ;load status
                       >            cmp_flag $ff
078e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0790 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0792 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
0793 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0795 : 48              >            pha         ;use stack to load status
0796 : a901            >            lda #1     ;precharge accu
0798 : 28              >            plp
                        
0799 : 48                       pha
                                tst_a 1,0
079a : 08              >            php         ;save flags
079b : 08              >            php
079c : c901            >            cmp #1     ;test result
                       >            trap_ne
079e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a0 : 68              >            pla         ;load status
                       >            cmp_flag 0
07a1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a5 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07a6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07a8 : 48              >            pha         ;use stack to load status
07a9 : a900            >            lda #0     ;precharge accu
07ab : 28              >            plp
                        
07ac : 48                       pha
                                tst_a 0,$ff
07ad : 08              >            php         ;save flags
07ae : 08              >            php
07af : c900            >            cmp #0     ;test result
                       >            trap_ne
07b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b3 : 68              >            pla         ;load status
                       >            cmp_flag $ff
07b4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b8 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07bb : 48              >            pha         ;use stack to load status
07bc : a9ff            >            lda #$ff     ;precharge accu
07be : 28              >            plp
                        
07bf : 48                       pha
                                tst_a $ff,0
07c0 : 08              >            php         ;save flags
07c1 : 08              >            php
07c2 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07c6 : 68              >            pla         ;load status
                       >            cmp_flag 0
07c7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cb : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
07cc : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
07ce : 48              >            pha         ;use stack to load status
07cf : a900            >            lda #0     ;precharge accu
07d1 : 28              >            plp
                        
07d2 : 68                       pla
                                tst_a $ff,$ff-zero
07d3 : 08              >            php         ;save flags
07d4 : 08              >            php
07d5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d9 : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
07da : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07de : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07df : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07e1 : 48              >            pha         ;use stack to load status
07e2 : a9ff            >            lda #$ff     ;precharge accu
07e4 : 28              >            plp
                        
07e5 : 68                       pla
                                tst_a 0,zero
07e6 : 08              >            php         ;save flags
07e7 : 08              >            php
07e8 : c900            >            cmp #0     ;test result
                       >            trap_ne
07ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ec : 68              >            pla         ;load status
                       >            cmp_flag zero
07ed : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f1 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
07f2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07f4 : 48              >            pha         ;use stack to load status
07f5 : a9fe            >            lda #$fe     ;precharge accu
07f7 : 28              >            plp
                        
07f8 : 68                       pla
                                tst_a 1,$ff-zero-minus
07f9 : 08              >            php         ;save flags
07fa : 08              >            php
07fb : c901            >            cmp #1     ;test result
                       >            trap_ne
07fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ff : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero-minus
0800 : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0804 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0805 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0807 : 48              >            pha         ;use stack to load status
0808 : a900            >            lda #0     ;precharge accu
080a : 28              >            plp
                        
080b : 68                       pla
                                tst_a $ff,minus
080c : 08              >            php         ;save flags
080d : 08              >            php
080e : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0810 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0812 : 68              >            pla         ;load status
                       >            cmp_flag minus
0813 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0817 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0818 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
081a : 48              >            pha         ;use stack to load status
081b : a9ff            >            lda #$ff     ;precharge accu
081d : 28              >            plp
                        
081e : 68                       pla
                                tst_a 0,$ff-minus
081f : 08              >            php         ;save flags
0820 : 08              >            php
0821 : c900            >            cmp #0     ;test result
                       >            trap_ne
0823 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0825 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0826 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0828 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082a : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
082b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
082d : 48              >            pha         ;use stack to load status
082e : a9fe            >            lda #$fe     ;precharge accu
0830 : 28              >            plp
                        
0831 : 68                       pla
                                tst_a 1,0
0832 : 08              >            php         ;save flags
0833 : 08              >            php
0834 : c901            >            cmp #1     ;test result
                       >            trap_ne
0836 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0838 : 68              >            pla         ;load status
                       >            cmp_flag 0
0839 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
083b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083d : 28              >            plp         ;restore status
                        
083e : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
0840 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0842 : c0aa                     cpy #$aa
                                trap_ne
0844 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0846 : ad0002          >            lda test_case   ;previous test
0849 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
084b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
084d : a906            >            lda #test_num   ;*** next tests' number
084f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
0852 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0854 : 48              >            pha         ;use stack to load status
0855 : a93c            >            lda #$3c     ;precharge accu
0857 : 28              >            plp
                        
0858 : 49c3                     eor #$c3
                                tst_a $ff,fn
085a : 08              >            php         ;save flags
085b : 08              >            php
085c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
085e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0860 : 68              >            pla         ;load status
                       >            cmp_flag fn
0861 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0863 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0865 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0866 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0868 : 48              >            pha         ;use stack to load status
0869 : a9c3            >            lda #$c3     ;precharge accu
086b : 28              >            plp
                        
086c : 49c3                     eor #$c3
                                tst_a 0,fz
086e : 08              >            php         ;save flags
086f : 08              >            php
0870 : c900            >            cmp #0     ;test result
                       >            trap_ne
0872 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0874 : 68              >            pla         ;load status
                       >            cmp_flag fz
0875 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0877 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0879 : 28              >            plp         ;restore status
                        
                                next_test
087a : ad0002          >            lda test_case   ;previous test
087d : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
087f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
0881 : a907            >            lda #test_num   ;*** next tests' number
0883 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
0886 : a224                     ldx #$24
0888 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
088a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
088c : 48              >            pha         ;use stack to load status
088d : a918            >            lda #$18     ;precharge accu
088f : 28              >            plp
                        
0890 : ea                       nop
                                tst_a $18,0
0891 : 08              >            php         ;save flags
0892 : 08              >            php
0893 : c918            >            cmp #$18     ;test result
                       >            trap_ne
0895 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0897 : 68              >            pla         ;load status
                       >            cmp_flag 0
0898 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
089a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089c : 28              >            plp         ;restore status
                        
089d : e024                     cpx #$24
                                trap_ne
089f : d0fe            >        bne *           ;failed not equal (non zero)
                        
08a1 : c042                     cpy #$42
                                trap_ne
08a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08a5 : a2db                     ldx #$db
08a7 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
08ab : 48              >            pha         ;use stack to load status
08ac : a9e7            >            lda #$e7     ;precharge accu
08ae : 28              >            plp
                        
08af : ea                       nop
                                tst_a $e7,$ff
08b0 : 08              >            php         ;save flags
08b1 : 08              >            php
08b2 : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
08b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08b6 : 68              >            pla         ;load status
                       >            cmp_flag $ff
08b7 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08bb : 28              >            plp         ;restore status
                        
08bc : e0db                     cpx #$db
                                trap_ne
08be : d0fe            >        bne *           ;failed not equal (non zero)
                        
08c0 : c0bd                     cpy #$bd
                                trap_ne
08c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08c4 : ad0002          >            lda test_case   ;previous test
08c7 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
08cb : a908            >            lda #test_num   ;*** next tests' number
08cd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
08d0 : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
08d2 : 48              >            pha         ;use stack to load status
08d3 : 28              >            plp
                        
08d4 : a946                     lda #'F'
08d6 : a241                     ldx #'A'
08d8 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
08da : 4c3c36                   jmp test_far
08dd : ea                       nop
08de : ea                       nop
                                trap_ne         ;runover protection
08df : d0fe            >        bne *           ;failed not equal (non zero)
                        
08e1 : e8                       inx
08e2 : e8                       inx
08e3 :                  far_ret 
                                trap_eq         ;returned flags OK?
08e3 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
08e5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
08e7 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
08e9 : 50fe            >        bvc *           ;failed overflow clear
                        
08eb : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
08ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ef : e042                     cpx #('A'+1)
                                trap_ne
08f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08f3 : c04f                     cpy #('R'-3)
                                trap_ne
08f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08f7 : ca                       dex
08f8 : c8                       iny
08f9 : c8                       iny
08fa : c8                       iny
08fb : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
08fd : 4c0609                   jmp test_near
0900 : ea                       nop
0901 : ea                       nop
                                trap_ne         ;runover protection
0902 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0904 : e8                       inx
0905 : e8                       inx
0906 :                  test_near
                                trap_eq         ;passed flags OK?
0906 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0908 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
090a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
090c : 50fe            >        bvc *           ;failed overflow clear
                        
090e : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
0910 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0912 : e041                     cpx #'A'
                                trap_ne
0914 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0916 : c052                     cpy #'R'
                                trap_ne
0918 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
091a : ad0002          >            lda test_case   ;previous test
091d : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
091f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0921 : a909            >            lda #test_num   ;*** next tests' number
0923 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0926 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0928 : 48              >            pha         ;use stack to load status
0929 : 28              >            plp
                        
092a : a949                     lda #'I'
092c : a24e                     ldx #'N'
092e : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
0930 : 6c6a36                   jmp (ptr_tst_ind)
0933 : ea                       nop
                                trap_ne         ;runover protection
0934 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0936 : 88                       dey
0937 : 88                       dey
0938 :                  ind_ret 
0938 : 08                       php             ;either SP or Y count will fail, if we do not hit
0939 : 88                       dey
093a : 88                       dey
093b : 88                       dey
093c : 28                       plp
                                trap_eq         ;returned flags OK?
093d : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
093f : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0941 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0943 : 50fe            >        bvc *           ;failed overflow clear
                        
0945 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0947 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0949 : e04f                     cpx #('N'+1)
                                trap_ne
094b : d0fe            >        bne *           ;failed not equal (non zero)
                        
094d : c03e                     cpy #('D'-6)
                                trap_ne
094f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0951 : ba                       tsx             ;SP check
0952 : e0ff                     cpx #$ff
                                trap_ne
0954 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0956 : ad0002          >            lda test_case   ;previous test
0959 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
095b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
095d : a90a            >            lda #test_num   ;*** next tests' number
095f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
0962 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0964 : 48              >            pha         ;use stack to load status
0965 : 28              >            plp
                        
0966 : a94a                     lda #'J'
0968 : a253                     ldx #'S'
096a : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
096c : 20a636                   jsr test_jsr
096e =                  jsr_ret = *-1           ;last address of jsr = return address
096f : 08                       php             ;either SP or Y count will fail, if we do not hit
0970 : 88                       dey
0971 : 88                       dey
0972 : 88                       dey
0973 : 28                       plp
                                trap_eq         ;returned flags OK?
0974 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0976 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0978 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
097a : 50fe            >        bvc *           ;failed overflow clear
                        
097c : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
097e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0980 : e054                     cpx #('S'+1)
                                trap_ne
0982 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0984 : c04c                     cpy #('R'-6)
                                trap_ne
0986 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0988 : ba                       tsx             ;sp?
0989 : e0ff                     cpx #$ff
                                trap_ne
098b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
098d : ad0002          >            lda test_case   ;previous test
0990 : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0992 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
0994 : a90b            >            lda #test_num   ;*** next tests' number
0996 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                set_stat 0
                       >            load_flag 0
0999 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
099b : 48              >            pha         ;use stack to load status
099c : 28              >            plp
                        
099d : a942                     lda #'B'
099f : a252                     ldx #'R'
09a1 : a04b                     ldy #'K'        ;N=0, V=0, Z=0, C=0
09a3 : 00                       brk
                            else
                                lda #hi brk_ret ;emulated break
                                pha
                                lda #lo brk_ret
                                pha
                                lda #fao        ;set break & unused on stack
                                pha
                                set_stat intdis
                                lda #'B'
                                ldx #'R'
                                ldy #'K'        ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
09a4 : 88                       dey             ;should not be executed
09a5 :                  brk_ret                 ;address of break return
09a5 : 08                       php             ;either SP or Y count will fail, if we do not hit
09a6 : 88                       dey
09a7 : 88                       dey
09a8 : 88                       dey
09a9 : c9e8                     cmp #('B'^$aa)  ;returned registers OK?
                                trap_ne
09ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ad : e053                     cpx #('R'+1)
                                trap_ne
09af : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b1 : c045                     cpy #('K'-6)
                                trap_ne
09b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b5 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
09b6 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
09b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ba : ba                       tsx             ;sp?
09bb : e0ff                     cpx #$ff
                                trap_ne
09bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09bf : ad0002          >            lda test_case   ;previous test
09c2 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
09c6 : a90c            >            lda #test_num   ;*** next tests' number
09c8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
09cb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09cd : 48              >            pha         ;use stack to load status
09ce : 28              >            plp
                        
09cf : 18                       clc
                                tst_stat $ff-carry
09d0 : 08              >            php         ;save status
09d1 : 08              >            php         ;use stack to retrieve status
09d2 : 68              >            pla
                       >            cmp_flag $ff-carry
09d3 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09d7 : 28              >            plp         ;restore status
                        
09d8 : 38                       sec
                                tst_stat $ff
09d9 : 08              >            php         ;save status
09da : 08              >            php         ;use stack to retrieve status
09db : 68              >            pla
                       >            cmp_flag $ff
09dc : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09e0 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
09e1 : 58                       cli
                                tst_stat $ff-intdis
09e2 : 08              >            php         ;save status
09e3 : 08              >            php         ;use stack to retrieve status
09e4 : 68              >            pla
                       >            cmp_flag $ff-intdis
09e5 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09e9 : 28              >            plp         ;restore status
                        
09ea : 78                       sei
                                tst_stat $ff
09eb : 08              >            php         ;save status
09ec : 08              >            php         ;use stack to retrieve status
09ed : 68              >            pla
                       >            cmp_flag $ff
09ee : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09f2 : 28              >            plp         ;restore status
                        
                            endif
09f3 : d8                       cld
                                tst_stat $ff-decmode
09f4 : 08              >            php         ;save status
09f5 : 08              >            php         ;use stack to retrieve status
09f6 : 68              >            pla
                       >            cmp_flag $ff-decmode
09f7 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
09fb : 28              >            plp         ;restore status
                        
09fc : f8                       sed
                                tst_stat $ff
09fd : 08              >            php         ;save status
09fe : 08              >            php         ;use stack to retrieve status
09ff : 68              >            pla
                       >            cmp_flag $ff
0a00 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a04 : 28              >            plp         ;restore status
                        
0a05 : b8                       clv
                                tst_stat $ff-overfl
0a06 : 08              >            php         ;save status
0a07 : 08              >            php         ;use stack to retrieve status
0a08 : 68              >            pla
                       >            cmp_flag $ff-overfl
0a09 : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a0d : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a0e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a10 : 48              >            pha         ;use stack to load status
0a11 : 28              >            plp
                        
                                tst_stat 0
0a12 : 08              >            php         ;save status
0a13 : 08              >            php         ;use stack to retrieve status
0a14 : 68              >            pla
                       >            cmp_flag 0
0a15 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a19 : 28              >            plp         ;restore status
                        
0a1a : 38                       sec
                                tst_stat carry
0a1b : 08              >            php         ;save status
0a1c : 08              >            php         ;use stack to retrieve status
0a1d : 68              >            pla
                       >            cmp_flag carry
0a1e : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a22 : 28              >            plp         ;restore status
                        
0a23 : 18                       clc
                                tst_stat 0  
0a24 : 08              >            php         ;save status
0a25 : 08              >            php         ;use stack to retrieve status
0a26 : 68              >            pla
                       >            cmp_flag 0  
0a27 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a2b : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a2c : 78                       sei
                                tst_stat intdis
0a2d : 08              >            php         ;save status
0a2e : 08              >            php         ;use stack to retrieve status
0a2f : 68              >            pla
                       >            cmp_flag intdis
0a30 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a34 : 28              >            plp         ;restore status
                        
0a35 : 58                       cli
                                tst_stat 0
0a36 : 08              >            php         ;save status
0a37 : 08              >            php         ;use stack to retrieve status
0a38 : 68              >            pla
                       >            cmp_flag 0
0a39 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a3d : 28              >            plp         ;restore status
                        
                            endif  
0a3e : f8                       sed
                                tst_stat decmode
0a3f : 08              >            php         ;save status
0a40 : 08              >            php         ;use stack to retrieve status
0a41 : 68              >            pla
                       >            cmp_flag decmode
0a42 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a46 : 28              >            plp         ;restore status
                        
0a47 : d8                       cld
                                tst_stat 0  
0a48 : 08              >            php         ;save status
0a49 : 08              >            php         ;use stack to retrieve status
0a4a : 68              >            pla
                       >            cmp_flag 0  
0a4b : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a4f : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0a50 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0a52 : 48              >            pha         ;use stack to load status
0a53 : 28              >            plp
                        
                                tst_stat overfl
0a54 : 08              >            php         ;save status
0a55 : 08              >            php         ;use stack to retrieve status
0a56 : 68              >            pla
                       >            cmp_flag overfl
0a57 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a5b : 28              >            plp         ;restore status
                        
0a5c : b8                       clv
                                tst_stat 0
0a5d : 08              >            php         ;save status
0a5e : 08              >            php         ;use stack to retrieve status
0a5f : 68              >            pla
                       >            cmp_flag 0
0a60 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a64 : 28              >            plp         ;restore status
                        
                                next_test
0a65 : ad0002          >            lda test_case   ;previous test
0a68 : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0a6c : a90d            >            lda #test_num   ;*** next tests' number
0a6e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0a71 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0a73 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a75 : 48              >            pha         ;use stack to load status
0a76 : 28              >            plp
                        
0a77 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0a78 : 08              >            php         ;save flags
0a79 : 08              >            php
0a7a : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0a7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7e : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0a7f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a83 : 28              >            plp         ;restore status
                        
0a84 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0a85 : 08              >            php         ;save flags
0a86 : 08              >            php
0a87 : e000            >            cpx #0     ;test result
                       >            trap_ne
0a89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a8b : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0a8c : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a90 : 28              >            plp         ;restore status
                        
0a91 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0a92 : 08              >            php         ;save flags
0a93 : 08              >            php
0a94 : e001            >            cpx #1     ;test result
                       >            trap_ne
0a96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a98 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus-zero
0a99 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a9d : 28              >            plp         ;restore status
                        
0a9e : ca                       dex             ;00
                                tst_x 0,$ff-minus
0a9f : 08              >            php         ;save flags
0aa0 : 08              >            php
0aa1 : e000            >            cpx #0     ;test result
                       >            trap_ne
0aa3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa5 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0aa6 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aaa : 28              >            plp         ;restore status
                        
0aab : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0aac : 08              >            php         ;save flags
0aad : 08              >            php
0aae : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ab0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab2 : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0ab3 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ab5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab7 : 28              >            plp         ;restore status
                        
0ab8 : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0ab9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0abb : 48              >            pha         ;use stack to load status
0abc : 28              >            plp
                        
0abd : e8                       inx             ;ff
                                tst_x $ff,minus
0abe : 08              >            php         ;save flags
0abf : 08              >            php
0ac0 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ac2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac4 : 68              >            pla         ;load status
                       >            cmp_flag minus
0ac5 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ac7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac9 : 28              >            plp         ;restore status
                        
0aca : e8                       inx             ;00
                                tst_x 0,zero
0acb : 08              >            php         ;save flags
0acc : 08              >            php
0acd : e000            >            cpx #0     ;test result
                       >            trap_ne
0acf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad1 : 68              >            pla         ;load status
                       >            cmp_flag zero
0ad2 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad6 : 28              >            plp         ;restore status
                        
0ad7 : e8                       inx             ;01
                                tst_x 1,0
0ad8 : 08              >            php         ;save flags
0ad9 : 08              >            php
0ada : e001            >            cpx #1     ;test result
                       >            trap_ne
0adc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ade : 68              >            pla         ;load status
                       >            cmp_flag 0
0adf : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ae1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae3 : 28              >            plp         ;restore status
                        
0ae4 : ca                       dex             ;00
                                tst_x 0,zero
0ae5 : 08              >            php         ;save flags
0ae6 : 08              >            php
0ae7 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ae9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aeb : 68              >            pla         ;load status
                       >            cmp_flag zero
0aec : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af0 : 28              >            plp         ;restore status
                        
0af1 : ca                       dex             ;ff
                                tst_x $ff,minus
0af2 : 08              >            php         ;save flags
0af3 : 08              >            php
0af4 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0af6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af8 : 68              >            pla         ;load status
                       >            cmp_flag minus
0af9 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0afb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0afd : 28              >            plp         ;restore status
                        
                        
0afe : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b00 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b02 : 48              >            pha         ;use stack to load status
0b03 : 28              >            plp
                        
0b04 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b05 : 08              >            php         ;save flags
0b06 : 08              >            php
0b07 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0b : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0b0c : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b10 : 28              >            plp         ;restore status
                        
0b11 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b12 : 08              >            php         ;save flags
0b13 : 08              >            php
0b14 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b18 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0b19 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1d : 28              >            plp         ;restore status
                        
0b1e : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0b1f : 08              >            php         ;save flags
0b20 : 08              >            php
0b21 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b25 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus-zero
0b26 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2a : 28              >            plp         ;restore status
                        
0b2b : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b2c : 08              >            php         ;save flags
0b2d : 08              >            php
0b2e : c000            >            cpy #0     ;test result
                       >            trap_ne
0b30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b32 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0b33 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b37 : 28              >            plp         ;restore status
                        
0b38 : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0b39 : 08              >            php         ;save flags
0b3a : 08              >            php
0b3b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3f : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0b40 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b44 : 28              >            plp         ;restore status
                        
0b45 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0b46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b48 : 48              >            pha         ;use stack to load status
0b49 : 28              >            plp
                        
0b4a : c8                       iny             ;ff
                                tst_y $ff,0+minus
0b4b : 08              >            php         ;save flags
0b4c : 08              >            php
0b4d : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b51 : 68              >            pla         ;load status
                       >            cmp_flag 0+minus
0b52 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b56 : 28              >            plp         ;restore status
                        
0b57 : c8                       iny             ;00
                                tst_y 0,zero
0b58 : 08              >            php         ;save flags
0b59 : 08              >            php
0b5a : c000            >            cpy #0     ;test result
                       >            trap_ne
0b5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5e : 68              >            pla         ;load status
                       >            cmp_flag zero
0b5f : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b63 : 28              >            plp         ;restore status
                        
0b64 : c8                       iny             ;01
                                tst_y 1,0
0b65 : 08              >            php         ;save flags
0b66 : 08              >            php
0b67 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6b : 68              >            pla         ;load status
                       >            cmp_flag 0
0b6c : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b70 : 28              >            plp         ;restore status
                        
0b71 : 88                       dey             ;00
                                tst_y 0,zero
0b72 : 08              >            php         ;save flags
0b73 : 08              >            php
0b74 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b78 : 68              >            pla         ;load status
                       >            cmp_flag zero
0b79 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7d : 28              >            plp         ;restore status
                        
0b7e : 88                       dey             ;ff
                                tst_y $ff,minus
0b7f : 08              >            php         ;save flags
0b80 : 08              >            php
0b81 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b85 : 68              >            pla         ;load status
                       >            cmp_flag minus
0b86 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8a : 28              >            plp         ;restore status
                        
                                        
0b8b : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0b8d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b8f : 48              >            pha         ;use stack to load status
0b90 : 28              >            plp
                        
0b91 : 8a                       txa
                                tst_a $ff,$ff-zero
0b92 : 08              >            php         ;save flags
0b93 : 08              >            php
0b94 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b98 : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0b99 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9d : 28              >            plp         ;restore status
                        
0b9e : 08                       php
0b9f : e8                       inx             ;00
0ba0 : 28                       plp
0ba1 : 8a                       txa
                                tst_a 0,$ff-minus
0ba2 : 08              >            php         ;save flags
0ba3 : 08              >            php
0ba4 : c900            >            cmp #0     ;test result
                       >            trap_ne
0ba6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba8 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0ba9 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bad : 28              >            plp         ;restore status
                        
0bae : 08                       php
0baf : e8                       inx             ;01
0bb0 : 28                       plp
0bb1 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0bb2 : 08              >            php         ;save flags
0bb3 : 08              >            php
0bb4 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb8 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus-zero
0bb9 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bbb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbd : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0bbe : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bc0 : 48              >            pha         ;use stack to load status
0bc1 : 28              >            plp
                        
0bc2 : 8a                       txa
                                tst_a 1,0
0bc3 : 08              >            php         ;save flags
0bc4 : 08              >            php
0bc5 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc9 : 68              >            pla         ;load status
                       >            cmp_flag 0
0bca : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bce : 28              >            plp         ;restore status
                        
0bcf : 08                       php
0bd0 : ca                       dex             ;00
0bd1 : 28                       plp
0bd2 : 8a                       txa
                                tst_a 0,zero
0bd3 : 08              >            php         ;save flags
0bd4 : 08              >            php
0bd5 : c900            >            cmp #0     ;test result
                       >            trap_ne
0bd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd9 : 68              >            pla         ;load status
                       >            cmp_flag zero
0bda : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bde : 28              >            plp         ;restore status
                        
0bdf : 08                       php
0be0 : ca                       dex             ;ff
0be1 : 28                       plp
0be2 : 8a                       txa
                                tst_a $ff,minus
0be3 : 08              >            php         ;save flags
0be4 : 08              >            php
0be5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0be7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be9 : 68              >            pla         ;load status
                       >            cmp_flag minus
0bea : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bee : 28              >            plp         ;restore status
                        
                                                
0bef : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0bf1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0bf3 : 48              >            pha         ;use stack to load status
0bf4 : 28              >            plp
                        
0bf5 : 98                       tya
                                tst_a $ff,$ff-zero
0bf6 : 08              >            php         ;save flags
0bf7 : 08              >            php
0bf8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfc : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0bfd : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c01 : 28              >            plp         ;restore status
                        
0c02 : 08                       php
0c03 : c8                       iny             ;00
0c04 : 28                       plp
0c05 : 98                       tya
                                tst_a 0,$ff-minus
0c06 : 08              >            php         ;save flags
0c07 : 08              >            php
0c08 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0c : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0c0d : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c0f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c11 : 28              >            plp         ;restore status
                        
0c12 : 08                       php
0c13 : c8                       iny             ;01
0c14 : 28                       plp
0c15 : 98                       tya
                                tst_a 1,$ff-minus-zero
0c16 : 08              >            php         ;save flags
0c17 : 08              >            php
0c18 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1c : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus-zero
0c1d : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c21 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c22 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c24 : 48              >            pha         ;use stack to load status
0c25 : 28              >            plp
                        
0c26 : 98                       tya
                                tst_a 1,0
0c27 : 08              >            php         ;save flags
0c28 : 08              >            php
0c29 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2d : 68              >            pla         ;load status
                       >            cmp_flag 0
0c2e : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c32 : 28              >            plp         ;restore status
                        
0c33 : 08                       php
0c34 : 88                       dey             ;00
0c35 : 28                       plp
0c36 : 98                       tya
                                tst_a 0,zero
0c37 : 08              >            php         ;save flags
0c38 : 08              >            php
0c39 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3d : 68              >            pla         ;load status
                       >            cmp_flag zero
0c3e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c42 : 28              >            plp         ;restore status
                        
0c43 : 08                       php
0c44 : 88                       dey             ;ff
0c45 : 28                       plp
0c46 : 98                       tya
                                tst_a $ff,minus
0c47 : 08              >            php         ;save flags
0c48 : 08              >            php
0c49 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4d : 68              >            pla         ;load status
                       >            cmp_flag minus
0c4e : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c52 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0c53 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0c55 : 48                       pha
0c56 : a2ff                     ldx #$ff        ;ff
0c58 : 8a                       txa
0c59 : 28                       plp             
0c5a : a8                       tay
                                tst_y $ff,$ff-zero
0c5b : 08              >            php         ;save flags
0c5c : 08              >            php
0c5d : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c61 : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0c62 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c66 : 28              >            plp         ;restore status
                        
0c67 : 08                       php
0c68 : e8                       inx             ;00
0c69 : 8a                       txa
0c6a : 28                       plp
0c6b : a8                       tay
                                tst_y 0,$ff-minus
0c6c : 08              >            php         ;save flags
0c6d : 08              >            php
0c6e : c000            >            cpy #0     ;test result
                       >            trap_ne
0c70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c72 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0c73 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c77 : 28              >            plp         ;restore status
                        
0c78 : 08                       php
0c79 : e8                       inx             ;01
0c7a : 8a                       txa
0c7b : 28                       plp
0c7c : a8                       tay
                                tst_y 1,$ff-minus-zero
0c7d : 08              >            php         ;save flags
0c7e : 08              >            php
0c7f : c001            >            cpy #1     ;test result
                       >            trap_ne
0c81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c83 : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus-zero
0c84 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c88 : 28              >            plp         ;restore status
                        
                                load_flag 0
0c89 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0c8b : 48                       pha
0c8c : a900                     lda #0
0c8e : 8a                       txa
0c8f : 28                       plp
0c90 : a8                       tay
                                tst_y 1,0
0c91 : 08              >            php         ;save flags
0c92 : 08              >            php
0c93 : c001            >            cpy #1     ;test result
                       >            trap_ne
0c95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c97 : 68              >            pla         ;load status
                       >            cmp_flag 0
0c98 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9c : 28              >            plp         ;restore status
                        
0c9d : 08                       php
0c9e : ca                       dex             ;00
0c9f : 8a                       txa
0ca0 : 28                       plp
0ca1 : a8                       tay
                                tst_y 0,zero
0ca2 : 08              >            php         ;save flags
0ca3 : 08              >            php
0ca4 : c000            >            cpy #0     ;test result
                       >            trap_ne
0ca6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca8 : 68              >            pla         ;load status
                       >            cmp_flag zero
0ca9 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cad : 28              >            plp         ;restore status
                        
0cae : 08                       php
0caf : ca                       dex             ;ff
0cb0 : 8a                       txa
0cb1 : 28                       plp
0cb2 : a8                       tay
                                tst_y $ff,minus
0cb3 : 08              >            php         ;save flags
0cb4 : 08              >            php
0cb5 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb9 : 68              >            pla         ;load status
                       >            cmp_flag minus
0cba : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cbe : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0cbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0cc1 : 48                       pha
0cc2 : a0ff                     ldy #$ff        ;ff
0cc4 : 98                       tya
0cc5 : 28                       plp
0cc6 : aa                       tax
                                tst_x $ff,$ff-zero
0cc7 : 08              >            php         ;save flags
0cc8 : 08              >            php
0cc9 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ccb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ccd : 68              >            pla         ;load status
                       >            cmp_flag $ff-zero
0cce : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd2 : 28              >            plp         ;restore status
                        
0cd3 : 08                       php
0cd4 : c8                       iny             ;00
0cd5 : 98                       tya
0cd6 : 28                       plp
0cd7 : aa                       tax
                                tst_x 0,$ff-minus
0cd8 : 08              >            php         ;save flags
0cd9 : 08              >            php
0cda : e000            >            cpx #0     ;test result
                       >            trap_ne
0cdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cde : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus
0cdf : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce3 : 28              >            plp         ;restore status
                        
0ce4 : 08                       php
0ce5 : c8                       iny             ;01
0ce6 : 98                       tya
0ce7 : 28                       plp
0ce8 : aa                       tax
                                tst_x 1,$ff-minus-zero
0ce9 : 08              >            php         ;save flags
0cea : 08              >            php
0ceb : e001            >            cpx #1     ;test result
                       >            trap_ne
0ced : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cef : 68              >            pla         ;load status
                       >            cmp_flag $ff-minus-zero
0cf0 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf4 : 28              >            plp         ;restore status
                        
                                load_flag 0
0cf5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0cf7 : 48                       pha
0cf8 : a900                     lda #0          ;preset status
0cfa : 98                       tya
0cfb : 28                       plp
0cfc : aa                       tax
                                tst_x 1,0
0cfd : 08              >            php         ;save flags
0cfe : 08              >            php
0cff : e001            >            cpx #1     ;test result
                       >            trap_ne
0d01 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d03 : 68              >            pla         ;load status
                       >            cmp_flag 0
0d04 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d08 : 28              >            plp         ;restore status
                        
0d09 : 08                       php
0d0a : 88                       dey             ;00
0d0b : 98                       tya
0d0c : 28                       plp
0d0d : aa                       tax
                                tst_x 0,zero
0d0e : 08              >            php         ;save flags
0d0f : 08              >            php
0d10 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d14 : 68              >            pla         ;load status
                       >            cmp_flag zero
0d15 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d19 : 28              >            plp         ;restore status
                        
0d1a : 08                       php
0d1b : 88                       dey             ;ff
0d1c : 98                       tya
0d1d : 28                       plp
0d1e : aa                       tax
                                tst_x $ff,minus
0d1f : 08              >            php         ;save flags
0d20 : 08              >            php
0d21 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d25 : 68              >            pla         ;load status
                       >            cmp_flag minus
0d26 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2a : 28              >            plp         ;restore status
                        
                                next_test
0d2b : ad0002          >            lda test_case   ;previous test
0d2e : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0d32 : a90e            >            lda #test_num   ;*** next tests' number
0d34 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
0d37 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0d39 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d3b : 48              >            pha         ;use stack to load status
0d3c : 28              >            plp
                        
0d3d : 9a                       txs
0d3e : 08                       php
0d3f : ad0101                   lda $101
                                cmp_flag $ff
0d42 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d44 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d48 : 48              >            pha         ;use stack to load status
0d49 : 28              >            plp
                        
0d4a : 9a                       txs
0d4b : 08                       php
0d4c : ad0101                   lda $101
                                cmp_flag 0
0d4f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d51 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d53 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0d54 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d56 : 48              >            pha         ;use stack to load status
0d57 : 28              >            plp
                        
0d58 : 9a                       txs
0d59 : 08                       php
0d5a : ad0001                   lda $100
                                cmp_flag $ff
0d5d : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d5f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d61 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d63 : 48              >            pha         ;use stack to load status
0d64 : 28              >            plp
                        
0d65 : 9a                       txs
0d66 : 08                       php
0d67 : ad0001                   lda $100
                                cmp_flag 0
0d6a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d6c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d6e : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0d6f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d71 : 48              >            pha         ;use stack to load status
0d72 : 28              >            plp
                        
0d73 : 9a                       txs
0d74 : 08                       php
0d75 : adff01                   lda $1ff
                                cmp_flag $ff
0d78 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d7a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d7c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d7e : 48              >            pha         ;use stack to load status
0d7f : 28              >            plp
                        
0d80 : 9a                       txs
0d81 : 08                       php
0d82 : adff01                   lda $1ff
                                cmp_flag 0
0d85 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0d87 : a201                     ldx #1
0d89 : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0d8a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d8c : 48              >            pha         ;use stack to load status
0d8d : 28              >            plp
                        
0d8e : ba                       tsx             ;clears Z, N
0d8f : 08                       php             ;sp=00
0d90 : e001                     cpx #1
                                trap_ne
0d92 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d94 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0d97 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d99 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0d9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d9d : 48              >            pha         ;use stack to load status
0d9e : 28              >            plp
                        
0d9f : ba                       tsx             ;clears N, sets Z
0da0 : 08                       php             ;sp=ff
0da1 : e000                     cpx #0
                                trap_ne
0da3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0da5 : ad0001                   lda $100
                                cmp_flag $ff-minus
0da8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0daa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0dac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dae : 48              >            pha         ;use stack to load status
0daf : 28              >            plp
                        
0db0 : ba                       tsx             ;clears N, sets Z
0db1 : 08                       php             ;sp=fe
0db2 : e0ff                     cpx #$ff
                                trap_ne
0db4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0db6 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0db9 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dbb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0dbd : a201                     ldx #1
0dbf : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0dc0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dc2 : 48              >            pha         ;use stack to load status
0dc3 : 28              >            plp
                        
0dc4 : ba                       tsx             ;clears Z, N
0dc5 : 08                       php             ;sp=00
0dc6 : e001                     cpx #1
                                trap_ne
0dc8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dca : ad0101                   lda $101
                                cmp_flag 0
0dcd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dcf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dd1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dd3 : 48              >            pha         ;use stack to load status
0dd4 : 28              >            plp
                        
0dd5 : ba                       tsx             ;clears N, sets Z
0dd6 : 08                       php             ;sp=ff
0dd7 : e000                     cpx #0
                                trap_ne
0dd9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ddb : ad0001                   lda $100
                                cmp_flag zero
0dde : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0de0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0de2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0de4 : 48              >            pha         ;use stack to load status
0de5 : 28              >            plp
                        
0de6 : ba                       tsx             ;clears N, sets Z
0de7 : 08                       php             ;sp=fe
0de8 : e0ff                     cpx #$ff
                                trap_ne
0dea : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dec : adff01                   lda $1ff
                                cmp_flag minus
0def : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0df1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df3 : 68                       pla             ;sp=ff
                                next_test
0df4 : ad0002          >            lda test_case   ;previous test
0df7 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0df9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0dfb : a90f            >            lda #test_num   ;*** next tests' number
0dfd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e00 : a003                     ldy #3
0e02 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e02 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e04 : 48              >            pha         ;use stack to load status
0e05 : 28              >            plp
                        
0e06 : b613                     ldx zp1,y
0e08 : 08                       php         ;test stores do not alter flags
0e09 : 8a                       txa
0e0a : 49c3                     eor #$c3
0e0c : 28                       plp
0e0d : 990302                   sta abst,y
0e10 : 08                       php         ;flags after load/store sequence
0e11 : 49c3                     eor #$c3
0e13 : d90802                   cmp abs1,y  ;test result
                                trap_ne
0e16 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e18 : 68                       pla         ;load status
                                eor_flag 0
0e19 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e1b : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e1e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e20 : 88                       dey
0e21 : 10df                     bpl tldx                  
                        
0e23 : a003                     ldy #3
0e25 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e25 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e27 : 48              >            pha         ;use stack to load status
0e28 : 28              >            plp
                        
0e29 : b613                     ldx zp1,y
0e2b : 08                       php         ;test stores do not alter flags
0e2c : 8a                       txa
0e2d : 49c3                     eor #$c3
0e2f : 28                       plp
0e30 : 990302                   sta abst,y
0e33 : 08                       php         ;flags after load/store sequence
0e34 : 49c3                     eor #$c3
0e36 : d90802                   cmp abs1,y  ;test result
                                trap_ne
0e39 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e3b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e3c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e3e : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e41 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e43 : 88                       dey
0e44 : 10df                     bpl tldx1                  
                        
0e46 : a003                     ldy #3
0e48 :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0e48 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e4a : 48              >            pha         ;use stack to load status
0e4b : 28              >            plp
                        
0e4c : be0802                   ldx abs1,y
0e4f : 08                       php         ;test stores do not alter flags
0e50 : 8a                       txa
0e51 : 49c3                     eor #$c3
0e53 : aa                       tax
0e54 : 28                       plp
0e55 : 960c                     stx zpt,y
0e57 : 08                       php         ;flags after load/store sequence
0e58 : 49c3                     eor #$c3
0e5a : d91300                   cmp zp1,y   ;test result
                                trap_ne
0e5d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e5f : 68                       pla         ;load status
                                eor_flag 0
0e60 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e62 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e65 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e67 : 88                       dey
0e68 : 10de                     bpl tldx2                  
                        
0e6a : a003                     ldy #3
0e6c :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0e6c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e6e : 48              >            pha         ;use stack to load status
0e6f : 28              >            plp
                        
0e70 : be0802                   ldx abs1,y
0e73 : 08                       php         ;test stores do not alter flags
0e74 : 8a                       txa
0e75 : 49c3                     eor #$c3
0e77 : aa                       tax
0e78 : 28                       plp
0e79 : 960c                     stx zpt,y
0e7b : 08                       php         ;flags after load/store sequence
0e7c : 49c3                     eor #$c3
0e7e : d91300                   cmp zp1,y   ;test result
                                trap_ne
0e81 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e83 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e84 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e86 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e89 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e8b : 88                       dey
0e8c : 10de                     bpl tldx3
                                
0e8e : a003                     ldy #3      ;testing store result
0e90 : a200                     ldx #0
0e92 : b90c00           tstx    lda zpt,y
0e95 : 49c3                     eor #$c3
0e97 : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0e9a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e9c : 960c                     stx zpt,y   ;clear                
0e9e : b90302                   lda abst,y
0ea1 : 49c3                     eor #$c3
0ea3 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
0ea6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ea8 : 8a                       txa
0ea9 : 990302                   sta abst,y  ;clear                
0eac : 88                       dey
0ead : 10e3                     bpl tstx
                                next_test
0eaf : ad0002          >            lda test_case   ;previous test
0eb2 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0eb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0eb6 : a910            >            lda #test_num   ;*** next tests' number
0eb8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0ebb : a0fd                     ldy #3+$fa
0ebd : b619             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0ebf : 8a                       txa
0ec0 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0ec3 : 88                       dey
0ec4 : c0fa                     cpy #$fa
0ec6 : b0f5                     bcs tldx4                  
0ec8 : a0fd                     ldy #3+$fa
0eca : be0e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0ecd : 9612                     stx zpt-$fa&$ff,y
0ecf : 88                       dey
0ed0 : c0fa                     cpy #$fa
0ed2 : b0f6                     bcs tldx5                  
0ed4 : a003                     ldy #3      ;testing wraparound result
0ed6 : a200                     ldx #0
0ed8 : b90c00           tstx1   lda zpt,y
0edb : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0ede : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ee0 : 960c                     stx zpt,y   ;clear                
0ee2 : b90302                   lda abst,y
0ee5 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
0ee8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eea : 8a                       txa
0eeb : 990302                   sta abst,y  ;clear                
0eee : 88                       dey
0eef : 10e7                     bpl tstx1
                                next_test
0ef1 : ad0002          >            lda test_case   ;previous test
0ef4 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ef6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0ef8 : a911            >            lda #test_num   ;*** next tests' number
0efa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0efd : a203                     ldx #3
0eff :                  tldy    
                                set_stat 0
                       >            load_flag 0
0eff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f01 : 48              >            pha         ;use stack to load status
0f02 : 28              >            plp
                        
0f03 : b413                     ldy zp1,x
0f05 : 08                       php         ;test stores do not alter flags
0f06 : 98                       tya
0f07 : 49c3                     eor #$c3
0f09 : 28                       plp
0f0a : 9d0302                   sta abst,x
0f0d : 08                       php         ;flags after load/store sequence
0f0e : 49c3                     eor #$c3
0f10 : dd0802                   cmp abs1,x  ;test result
                                trap_ne
0f13 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f15 : 68                       pla         ;load status
                                eor_flag 0
0f16 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f18 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f1b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f1d : ca                       dex
0f1e : 10df                     bpl tldy                  
                        
0f20 : a203                     ldx #3
0f22 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f22 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f24 : 48              >            pha         ;use stack to load status
0f25 : 28              >            plp
                        
0f26 : b413                     ldy zp1,x
0f28 : 08                       php         ;test stores do not alter flags
0f29 : 98                       tya
0f2a : 49c3                     eor #$c3
0f2c : 28                       plp
0f2d : 9d0302                   sta abst,x
0f30 : 08                       php         ;flags after load/store sequence
0f31 : 49c3                     eor #$c3
0f33 : dd0802                   cmp abs1,x  ;test result
                                trap_ne
0f36 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f38 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f39 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f3b : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f3e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f40 : ca                       dex
0f41 : 10df                     bpl tldy1                  
                        
0f43 : a203                     ldx #3
0f45 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0f45 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f47 : 48              >            pha         ;use stack to load status
0f48 : 28              >            plp
                        
0f49 : bc0802                   ldy abs1,x
0f4c : 08                       php         ;test stores do not alter flags
0f4d : 98                       tya
0f4e : 49c3                     eor #$c3
0f50 : a8                       tay
0f51 : 28                       plp
0f52 : 940c                     sty zpt,x
0f54 : 08                       php         ;flags after load/store sequence
0f55 : 49c3                     eor #$c3
0f57 : d513                     cmp zp1,x   ;test result
                                trap_ne
0f59 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f5b : 68                       pla         ;load status
                                eor_flag 0
0f5c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f5e : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f61 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f63 : ca                       dex
0f64 : 10df                     bpl tldy2                  
                        
0f66 : a203                     ldx #3
0f68 :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0f68 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f6a : 48              >            pha         ;use stack to load status
0f6b : 28              >            plp
                        
0f6c : bc0802                   ldy abs1,x
0f6f : 08                       php         ;test stores do not alter flags
0f70 : 98                       tya
0f71 : 49c3                     eor #$c3
0f73 : a8                       tay
0f74 : 28                       plp
0f75 : 940c                     sty zpt,x
0f77 : 08                       php         ;flags after load/store sequence
0f78 : 49c3                     eor #$c3
0f7a : d513                     cmp zp1,x   ;test result
                                trap_ne
0f7c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f7e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f7f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f81 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f84 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f86 : ca                       dex
0f87 : 10df                     bpl tldy3
                        
0f89 : a203                     ldx #3      ;testing store result
0f8b : a000                     ldy #0
0f8d : b50c             tsty    lda zpt,x
0f8f : 49c3                     eor #$c3
0f91 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0f93 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f95 : 940c                     sty zpt,x   ;clear                
0f97 : bd0302                   lda abst,x
0f9a : 49c3                     eor #$c3
0f9c : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0f9f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa1 : 8a                       txa
0fa2 : 9d0302                   sta abst,x  ;clear                
0fa5 : ca                       dex
0fa6 : 10e5                     bpl tsty
                                next_test
0fa8 : ad0002          >            lda test_case   ;previous test
0fab : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0faf : a912            >            lda #test_num   ;*** next tests' number
0fb1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0fb4 : a2fd                     ldx #3+$fa
0fb6 : b419             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0fb8 : 98                       tya
0fb9 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0fbc : ca                       dex
0fbd : e0fa                     cpx #$fa
0fbf : b0f5                     bcs tldy4                  
0fc1 : a2fd                     ldx #3+$fa
0fc3 : bc0e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0fc6 : 9412                     sty zpt-$fa&$ff,x
0fc8 : ca                       dex
0fc9 : e0fa                     cpx #$fa
0fcb : b0f6                     bcs tldy5                  
0fcd : a203                     ldx #3      ;testing wraparound result
0fcf : a000                     ldy #0
0fd1 : b50c             tsty1   lda zpt,x
0fd3 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0fd5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fd7 : 940c                     sty zpt,x   ;clear                
0fd9 : bd0302                   lda abst,x
0fdc : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fdf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fe1 : 8a                       txa
0fe2 : 9d0302                   sta abst,x  ;clear                
0fe5 : ca                       dex
0fe6 : 10e9                     bpl tsty1
                                next_test
0fe8 : ad0002          >            lda test_case   ;previous test
0feb : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
0fef : a913            >            lda #test_num   ;*** next tests' number
0ff1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
0ff4 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
0ff6 : 48              >            pha         ;use stack to load status
0ff7 : 28              >            plp
                        
0ff8 : a613                     ldx zp1
0ffa : 08                       php         ;test stores do not alter flags
0ffb : 8a                       txa
0ffc : 49c3                     eor #$c3
0ffe : aa                       tax
0fff : 28                       plp
1000 : 8e0302                   stx abst
1003 : 08                       php         ;flags after load/store sequence
1004 : 49c3                     eor #$c3
1006 : aa                       tax
1007 : e0c3                     cpx #$c3    ;test result
                                trap_ne
1009 : d0fe            >        bne *           ;failed not equal (non zero)
                        
100b : 68                       pla         ;load status
                                eor_flag 0
100c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
100e : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1011 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1013 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1015 : 48              >            pha         ;use stack to load status
1016 : 28              >            plp
                        
1017 : a614                     ldx zp1+1
1019 : 08                       php         ;test stores do not alter flags
101a : 8a                       txa
101b : 49c3                     eor #$c3
101d : aa                       tax
101e : 28                       plp
101f : 8e0402                   stx abst+1
1022 : 08                       php         ;flags after load/store sequence
1023 : 49c3                     eor #$c3
1025 : aa                       tax
1026 : e082                     cpx #$82    ;test result
                                trap_ne
1028 : d0fe            >        bne *           ;failed not equal (non zero)
                        
102a : 68                       pla         ;load status
                                eor_flag 0
102b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
102d : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1030 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1032 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1034 : 48              >            pha         ;use stack to load status
1035 : 28              >            plp
                        
1036 : a615                     ldx zp1+2
1038 : 08                       php         ;test stores do not alter flags
1039 : 8a                       txa
103a : 49c3                     eor #$c3
103c : aa                       tax
103d : 28                       plp
103e : 8e0502                   stx abst+2
1041 : 08                       php         ;flags after load/store sequence
1042 : 49c3                     eor #$c3
1044 : aa                       tax
1045 : e041                     cpx #$41    ;test result
                                trap_ne
1047 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1049 : 68                       pla         ;load status
                                eor_flag 0
104a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
104c : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
104f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1051 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1053 : 48              >            pha         ;use stack to load status
1054 : 28              >            plp
                        
1055 : a616                     ldx zp1+3
1057 : 08                       php         ;test stores do not alter flags
1058 : 8a                       txa
1059 : 49c3                     eor #$c3
105b : aa                       tax
105c : 28                       plp
105d : 8e0602                   stx abst+3
1060 : 08                       php         ;flags after load/store sequence
1061 : 49c3                     eor #$c3
1063 : aa                       tax
1064 : e000                     cpx #0      ;test result
                                trap_ne
1066 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1068 : 68                       pla         ;load status
                                eor_flag 0
1069 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
106b : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
106e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1070 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1072 : 48              >            pha         ;use stack to load status
1073 : 28              >            plp
                        
1074 : a613                     ldx zp1  
1076 : 08                       php         ;test stores do not alter flags
1077 : 8a                       txa
1078 : 49c3                     eor #$c3
107a : aa                       tax
107b : 28                       plp
107c : 8e0302                   stx abst  
107f : 08                       php         ;flags after load/store sequence
1080 : 49c3                     eor #$c3
1082 : aa                       tax
1083 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
1085 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1087 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1088 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
108a : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
108d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
108f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1091 : 48              >            pha         ;use stack to load status
1092 : 28              >            plp
                        
1093 : a614                     ldx zp1+1
1095 : 08                       php         ;test stores do not alter flags
1096 : 8a                       txa
1097 : 49c3                     eor #$c3
1099 : aa                       tax
109a : 28                       plp
109b : 8e0402                   stx abst+1
109e : 08                       php         ;flags after load/store sequence
109f : 49c3                     eor #$c3
10a1 : aa                       tax
10a2 : e082                     cpx #$82    ;test result
                                trap_ne
10a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10a6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10a7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10a9 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
10ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10ae : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10b0 : 48              >            pha         ;use stack to load status
10b1 : 28              >            plp
                        
10b2 : a615                     ldx zp1+2
10b4 : 08                       php         ;test stores do not alter flags
10b5 : 8a                       txa
10b6 : 49c3                     eor #$c3
10b8 : aa                       tax
10b9 : 28                       plp
10ba : 8e0502                   stx abst+2
10bd : 08                       php         ;flags after load/store sequence
10be : 49c3                     eor #$c3
10c0 : aa                       tax
10c1 : e041                     cpx #$41    ;test result
                                trap_ne     ;
10c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10c5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10c6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10c8 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
10cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10cd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10cf : 48              >            pha         ;use stack to load status
10d0 : 28              >            plp
                        
10d1 : a616                     ldx zp1+3
10d3 : 08                       php         ;test stores do not alter flags
10d4 : 8a                       txa
10d5 : 49c3                     eor #$c3
10d7 : aa                       tax
10d8 : 28                       plp
10d9 : 8e0602                   stx abst+3
10dc : 08                       php         ;flags after load/store sequence
10dd : 49c3                     eor #$c3
10df : aa                       tax
10e0 : e000                     cpx #0      ;test result
                                trap_ne
10e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10e4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10e5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10e7 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
10ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
10ec : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10ee : 48              >            pha         ;use stack to load status
10ef : 28              >            plp
                        
10f0 : ae0802                   ldx abs1  
10f3 : 08                       php         ;test stores do not alter flags
10f4 : 8a                       txa
10f5 : 49c3                     eor #$c3
10f7 : aa                       tax
10f8 : 28                       plp
10f9 : 860c                     stx zpt  
10fb : 08                       php         ;flags after load/store sequence
10fc : 49c3                     eor #$c3
10fe : c513                     cmp zp1     ;test result
                                trap_ne
1100 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1102 : 68                       pla         ;load status
                                eor_flag 0
1103 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1105 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1108 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
110a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
110c : 48              >            pha         ;use stack to load status
110d : 28              >            plp
                        
110e : ae0902                   ldx abs1+1
1111 : 08                       php         ;test stores do not alter flags
1112 : 8a                       txa
1113 : 49c3                     eor #$c3
1115 : aa                       tax
1116 : 28                       plp
1117 : 860d                     stx zpt+1
1119 : 08                       php         ;flags after load/store sequence
111a : 49c3                     eor #$c3
111c : c514                     cmp zp1+1   ;test result
                                trap_ne
111e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1120 : 68                       pla         ;load status
                                eor_flag 0
1121 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1123 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1126 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1128 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
112a : 48              >            pha         ;use stack to load status
112b : 28              >            plp
                        
112c : ae0a02                   ldx abs1+2
112f : 08                       php         ;test stores do not alter flags
1130 : 8a                       txa
1131 : 49c3                     eor #$c3
1133 : aa                       tax
1134 : 28                       plp
1135 : 860e                     stx zpt+2
1137 : 08                       php         ;flags after load/store sequence
1138 : 49c3                     eor #$c3
113a : c515                     cmp zp1+2   ;test result
                                trap_ne
113c : d0fe            >        bne *           ;failed not equal (non zero)
                        
113e : 68                       pla         ;load status
                                eor_flag 0
113f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1141 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1144 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1146 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1148 : 48              >            pha         ;use stack to load status
1149 : 28              >            plp
                        
114a : ae0b02                   ldx abs1+3
114d : 08                       php         ;test stores do not alter flags
114e : 8a                       txa
114f : 49c3                     eor #$c3
1151 : aa                       tax
1152 : 28                       plp
1153 : 860f                     stx zpt+3
1155 : 08                       php         ;flags after load/store sequence
1156 : 49c3                     eor #$c3
1158 : c516                     cmp zp1+3   ;test result
                                trap_ne
115a : d0fe            >        bne *           ;failed not equal (non zero)
                        
115c : 68                       pla         ;load status
                                eor_flag 0
115d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
115f : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1162 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1164 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1166 : 48              >            pha         ;use stack to load status
1167 : 28              >            plp
                        
1168 : ae0802                   ldx abs1  
116b : 08                       php         ;test stores do not alter flags
116c : 8a                       txa
116d : 49c3                     eor #$c3
116f : aa                       tax
1170 : 28                       plp
1171 : 860c                     stx zpt  
1173 : 08                       php         ;flags after load/store sequence
1174 : 49c3                     eor #$c3
1176 : aa                       tax
1177 : e413                     cpx zp1     ;test result
                                trap_ne
1179 : d0fe            >        bne *           ;failed not equal (non zero)
                        
117b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
117c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
117e : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1181 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1183 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1185 : 48              >            pha         ;use stack to load status
1186 : 28              >            plp
                        
1187 : ae0902                   ldx abs1+1
118a : 08                       php         ;test stores do not alter flags
118b : 8a                       txa
118c : 49c3                     eor #$c3
118e : aa                       tax
118f : 28                       plp
1190 : 860d                     stx zpt+1
1192 : 08                       php         ;flags after load/store sequence
1193 : 49c3                     eor #$c3
1195 : aa                       tax
1196 : e414                     cpx zp1+1   ;test result
                                trap_ne
1198 : d0fe            >        bne *           ;failed not equal (non zero)
                        
119a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
119b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
119d : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
11a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11a4 : 48              >            pha         ;use stack to load status
11a5 : 28              >            plp
                        
11a6 : ae0a02                   ldx abs1+2
11a9 : 08                       php         ;test stores do not alter flags
11aa : 8a                       txa
11ab : 49c3                     eor #$c3
11ad : aa                       tax
11ae : 28                       plp
11af : 860e                     stx zpt+2
11b1 : 08                       php         ;flags after load/store sequence
11b2 : 49c3                     eor #$c3
11b4 : aa                       tax
11b5 : e415                     cpx zp1+2   ;test result
                                trap_ne
11b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11b9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11ba : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11bc : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
11bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11c3 : 48              >            pha         ;use stack to load status
11c4 : 28              >            plp
                        
11c5 : ae0b02                   ldx abs1+3
11c8 : 08                       php         ;test stores do not alter flags
11c9 : 8a                       txa
11ca : 49c3                     eor #$c3
11cc : aa                       tax
11cd : 28                       plp
11ce : 860f                     stx zpt+3
11d0 : 08                       php         ;flags after load/store sequence
11d1 : 49c3                     eor #$c3
11d3 : aa                       tax
11d4 : e416                     cpx zp1+3   ;test result
                                trap_ne
11d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11d8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11d9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11db : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
11de : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
11e0 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
11e2 : 48              >            pha         ;use stack to load status
11e3 : 28              >            plp
                        
11e4 : a2c3                     ldx #$c3
11e6 : 08                       php
11e7 : ec0802                   cpx abs1    ;test result
                                trap_ne
11ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
11ec : 68                       pla         ;load status
                                eor_flag 0
11ed : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11ef : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
11f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11f6 : 48              >            pha         ;use stack to load status
11f7 : 28              >            plp
                        
11f8 : a282                     ldx #$82
11fa : 08                       php
11fb : ec0902                   cpx abs1+1  ;test result
                                trap_ne
11fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
1200 : 68                       pla         ;load status
                                eor_flag 0
1201 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1203 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1206 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1208 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
120a : 48              >            pha         ;use stack to load status
120b : 28              >            plp
                        
120c : a241                     ldx #$41
120e : 08                       php
120f : ec0a02                   cpx abs1+2  ;test result
                                trap_ne
1212 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1214 : 68                       pla         ;load status
                                eor_flag 0
1215 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1217 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
121a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
121c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
121e : 48              >            pha         ;use stack to load status
121f : 28              >            plp
                        
1220 : a200                     ldx #0
1222 : 08                       php
1223 : ec0b02                   cpx abs1+3  ;test result
                                trap_ne
1226 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1228 : 68                       pla         ;load status
                                eor_flag 0
1229 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
122b : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
122e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1230 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1232 : 48              >            pha         ;use stack to load status
1233 : 28              >            plp
                        
1234 : a2c3                     ldx #$c3  
1236 : 08                       php
1237 : ec0802                   cpx abs1    ;test result
                                trap_ne
123a : d0fe            >        bne *           ;failed not equal (non zero)
                        
123c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
123d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
123f : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1242 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1244 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1246 : 48              >            pha         ;use stack to load status
1247 : 28              >            plp
                        
1248 : a282                     ldx #$82
124a : 08                       php
124b : ec0902                   cpx abs1+1  ;test result
                                trap_ne
124e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1250 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1251 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1253 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1256 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1258 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
125a : 48              >            pha         ;use stack to load status
125b : 28              >            plp
                        
125c : a241                     ldx #$41
125e : 08                       php
125f : ec0a02                   cpx abs1+2  ;test result
                                trap_ne
1262 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1264 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1265 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1267 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
126a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
126c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
126e : 48              >            pha         ;use stack to load status
126f : 28              >            plp
                        
1270 : a200                     ldx #0
1272 : 08                       php
1273 : ec0b02                   cpx abs1+3  ;test result
                                trap_ne
1276 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1278 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1279 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
127b : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
127e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1280 : a200                     ldx #0
1282 : a50c                     lda zpt  
1284 : 49c3                     eor #$c3
1286 : c513                     cmp zp1  
                                trap_ne     ;store to zp data
1288 : d0fe            >        bne *           ;failed not equal (non zero)
                        
128a : 860c                     stx zpt     ;clear                
128c : ad0302                   lda abst  
128f : 49c3                     eor #$c3
1291 : cd0802                   cmp abs1  
                                trap_ne     ;store to abs data
1294 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1296 : 8e0302                   stx abst    ;clear                
1299 : a50d                     lda zpt+1
129b : 49c3                     eor #$c3
129d : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
129f : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a1 : 860d                     stx zpt+1   ;clear                
12a3 : ad0402                   lda abst+1
12a6 : 49c3                     eor #$c3
12a8 : cd0902                   cmp abs1+1
                                trap_ne     ;store to abs data
12ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ad : 8e0402                   stx abst+1  ;clear                
12b0 : a50e                     lda zpt+2
12b2 : 49c3                     eor #$c3
12b4 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
12b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b8 : 860e                     stx zpt+2   ;clear                
12ba : ad0502                   lda abst+2
12bd : 49c3                     eor #$c3
12bf : cd0a02                   cmp abs1+2
                                trap_ne     ;store to abs data
12c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12c4 : 8e0502                   stx abst+2  ;clear                
12c7 : a50f                     lda zpt+3
12c9 : 49c3                     eor #$c3
12cb : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
12cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
12cf : 860f                     stx zpt+3   ;clear                
12d1 : ad0602                   lda abst+3
12d4 : 49c3                     eor #$c3
12d6 : cd0b02                   cmp abs1+3
                                trap_ne     ;store to abs data
12d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12db : 8e0602                   stx abst+3  ;clear                
                                next_test
12de : ad0002          >            lda test_case   ;previous test
12e1 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
12e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
12e5 : a914            >            lda #test_num   ;*** next tests' number
12e7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
12ea : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
12ec : 48              >            pha         ;use stack to load status
12ed : 28              >            plp
                        
12ee : a413                     ldy zp1  
12f0 : 08                       php         ;test stores do not alter flags
12f1 : 98                       tya
12f2 : 49c3                     eor #$c3
12f4 : a8                       tay
12f5 : 28                       plp
12f6 : 8c0302                   sty abst  
12f9 : 08                       php         ;flags after load/store sequence
12fa : 49c3                     eor #$c3
12fc : a8                       tay
12fd : c0c3                     cpy #$c3    ;test result
                                trap_ne
12ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1301 : 68                       pla         ;load status
                                eor_flag 0
1302 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1304 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1307 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1309 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
130b : 48              >            pha         ;use stack to load status
130c : 28              >            plp
                        
130d : a414                     ldy zp1+1
130f : 08                       php         ;test stores do not alter flags
1310 : 98                       tya
1311 : 49c3                     eor #$c3
1313 : a8                       tay
1314 : 28                       plp
1315 : 8c0402                   sty abst+1
1318 : 08                       php         ;flags after load/store sequence
1319 : 49c3                     eor #$c3
131b : a8                       tay
131c : c082                     cpy #$82    ;test result
                                trap_ne
131e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1320 : 68                       pla         ;load status
                                eor_flag 0
1321 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1323 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1326 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1328 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
132a : 48              >            pha         ;use stack to load status
132b : 28              >            plp
                        
132c : a415                     ldy zp1+2
132e : 08                       php         ;test stores do not alter flags
132f : 98                       tya
1330 : 49c3                     eor #$c3
1332 : a8                       tay
1333 : 28                       plp
1334 : 8c0502                   sty abst+2
1337 : 08                       php         ;flags after load/store sequence
1338 : 49c3                     eor #$c3
133a : a8                       tay
133b : c041                     cpy #$41    ;test result
                                trap_ne
133d : d0fe            >        bne *           ;failed not equal (non zero)
                        
133f : 68                       pla         ;load status
                                eor_flag 0
1340 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1342 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1345 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1347 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1349 : 48              >            pha         ;use stack to load status
134a : 28              >            plp
                        
134b : a416                     ldy zp1+3
134d : 08                       php         ;test stores do not alter flags
134e : 98                       tya
134f : 49c3                     eor #$c3
1351 : a8                       tay
1352 : 28                       plp
1353 : 8c0602                   sty abst+3
1356 : 08                       php         ;flags after load/store sequence
1357 : 49c3                     eor #$c3
1359 : a8                       tay
135a : c000                     cpy #0      ;test result
                                trap_ne
135c : d0fe            >        bne *           ;failed not equal (non zero)
                        
135e : 68                       pla         ;load status
                                eor_flag 0
135f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1361 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1364 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1366 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1368 : 48              >            pha         ;use stack to load status
1369 : 28              >            plp
                        
136a : a413                     ldy zp1  
136c : 08                       php         ;test stores do not alter flags
136d : 98                       tya
136e : 49c3                     eor #$c3
1370 : a8                       tay
1371 : 28                       plp
1372 : 8c0302                   sty abst  
1375 : 08                       php         ;flags after load/store sequence
1376 : 49c3                     eor #$c3
1378 : a8                       tay
1379 : c0c3                     cpy #$c3    ;test result
                                trap_ne
137b : d0fe            >        bne *           ;failed not equal (non zero)
                        
137d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
137e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1380 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1383 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1385 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1387 : 48              >            pha         ;use stack to load status
1388 : 28              >            plp
                        
1389 : a414                     ldy zp1+1
138b : 08                       php         ;test stores do not alter flags
138c : 98                       tya
138d : 49c3                     eor #$c3
138f : a8                       tay
1390 : 28                       plp
1391 : 8c0402                   sty abst+1
1394 : 08                       php         ;flags after load/store sequence
1395 : 49c3                     eor #$c3
1397 : a8                       tay
1398 : c082                     cpy #$82   ;test result
                                trap_ne
139a : d0fe            >        bne *           ;failed not equal (non zero)
                        
139c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
139d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
139f : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
13a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13a4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13a6 : 48              >            pha         ;use stack to load status
13a7 : 28              >            plp
                        
13a8 : a415                     ldy zp1+2
13aa : 08                       php         ;test stores do not alter flags
13ab : 98                       tya
13ac : 49c3                     eor #$c3
13ae : a8                       tay
13af : 28                       plp
13b0 : 8c0502                   sty abst+2
13b3 : 08                       php         ;flags after load/store sequence
13b4 : 49c3                     eor #$c3
13b6 : a8                       tay
13b7 : c041                     cpy #$41    ;test result
                                trap_ne
13b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13bb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13bc : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13be : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
13c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13c3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13c5 : 48              >            pha         ;use stack to load status
13c6 : 28              >            plp
                        
13c7 : a416                     ldy zp1+3
13c9 : 08                       php         ;test stores do not alter flags
13ca : 98                       tya
13cb : 49c3                     eor #$c3
13cd : a8                       tay
13ce : 28                       plp
13cf : 8c0602                   sty abst+3
13d2 : 08                       php         ;flags after load/store sequence
13d3 : 49c3                     eor #$c3
13d5 : a8                       tay
13d6 : c000                     cpy #0      ;test result
                                trap_ne
13d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13da : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13db : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13dd : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
13e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
13e2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13e4 : 48              >            pha         ;use stack to load status
13e5 : 28              >            plp
                        
13e6 : ac0802                   ldy abs1  
13e9 : 08                       php         ;test stores do not alter flags
13ea : 98                       tya
13eb : 49c3                     eor #$c3
13ed : a8                       tay
13ee : 28                       plp
13ef : 840c                     sty zpt  
13f1 : 08                       php         ;flags after load/store sequence
13f2 : 49c3                     eor #$c3
13f4 : a8                       tay
13f5 : c413                     cpy zp1     ;test result
                                trap_ne
13f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13f9 : 68                       pla         ;load status
                                eor_flag 0
13fa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13fc : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
13ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1401 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1403 : 48              >            pha         ;use stack to load status
1404 : 28              >            plp
                        
1405 : ac0902                   ldy abs1+1
1408 : 08                       php         ;test stores do not alter flags
1409 : 98                       tya
140a : 49c3                     eor #$c3
140c : a8                       tay
140d : 28                       plp
140e : 840d                     sty zpt+1
1410 : 08                       php         ;flags after load/store sequence
1411 : 49c3                     eor #$c3
1413 : a8                       tay
1414 : c414                     cpy zp1+1   ;test result
                                trap_ne
1416 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1418 : 68                       pla         ;load status
                                eor_flag 0
1419 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
141b : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
141e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1420 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1422 : 48              >            pha         ;use stack to load status
1423 : 28              >            plp
                        
1424 : ac0a02                   ldy abs1+2
1427 : 08                       php         ;test stores do not alter flags
1428 : 98                       tya
1429 : 49c3                     eor #$c3
142b : a8                       tay
142c : 28                       plp
142d : 840e                     sty zpt+2
142f : 08                       php         ;flags after load/store sequence
1430 : 49c3                     eor #$c3
1432 : a8                       tay
1433 : c415                     cpy zp1+2   ;test result
                                trap_ne
1435 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1437 : 68                       pla         ;load status
                                eor_flag 0
1438 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
143a : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
143d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
143f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1441 : 48              >            pha         ;use stack to load status
1442 : 28              >            plp
                        
1443 : ac0b02                   ldy abs1+3
1446 : 08                       php         ;test stores do not alter flags
1447 : 98                       tya
1448 : 49c3                     eor #$c3
144a : a8                       tay
144b : 28                       plp
144c : 840f                     sty zpt+3
144e : 08                       php         ;flags after load/store sequence
144f : 49c3                     eor #$c3
1451 : a8                       tay
1452 : c416                     cpy zp1+3   ;test result
                                trap_ne
1454 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1456 : 68                       pla         ;load status
                                eor_flag 0
1457 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1459 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
145c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
145e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1460 : 48              >            pha         ;use stack to load status
1461 : 28              >            plp
                        
1462 : ac0802                   ldy abs1  
1465 : 08                       php         ;test stores do not alter flags
1466 : 98                       tya
1467 : 49c3                     eor #$c3
1469 : a8                       tay
146a : 28                       plp
146b : 840c                     sty zpt  
146d : 08                       php         ;flags after load/store sequence
146e : 49c3                     eor #$c3
1470 : a8                       tay
1471 : c513                     cmp zp1     ;test result
                                trap_ne
1473 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1475 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1476 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1478 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
147b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
147d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
147f : 48              >            pha         ;use stack to load status
1480 : 28              >            plp
                        
1481 : ac0902                   ldy abs1+1
1484 : 08                       php         ;test stores do not alter flags
1485 : 98                       tya
1486 : 49c3                     eor #$c3
1488 : a8                       tay
1489 : 28                       plp
148a : 840d                     sty zpt+1
148c : 08                       php         ;flags after load/store sequence
148d : 49c3                     eor #$c3
148f : a8                       tay
1490 : c514                     cmp zp1+1   ;test result
                                trap_ne
1492 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1494 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1495 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1497 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
149a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
149c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
149e : 48              >            pha         ;use stack to load status
149f : 28              >            plp
                        
14a0 : ac0a02                   ldy abs1+2
14a3 : 08                       php         ;test stores do not alter flags
14a4 : 98                       tya
14a5 : 49c3                     eor #$c3
14a7 : a8                       tay
14a8 : 28                       plp
14a9 : 840e                     sty zpt+2
14ab : 08                       php         ;flags after load/store sequence
14ac : 49c3                     eor #$c3
14ae : a8                       tay
14af : c515                     cmp zp1+2   ;test result
                                trap_ne
14b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14b3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14b4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14b6 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
14b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14bd : 48              >            pha         ;use stack to load status
14be : 28              >            plp
                        
14bf : ac0b02                   ldy abs1+3
14c2 : 08                       php         ;test stores do not alter flags
14c3 : 98                       tya
14c4 : 49c3                     eor #$c3
14c6 : a8                       tay
14c7 : 28                       plp
14c8 : 840f                     sty zpt+3
14ca : 08                       php         ;flags after load/store sequence
14cb : 49c3                     eor #$c3
14cd : a8                       tay
14ce : c516                     cmp zp1+3   ;test result
                                trap_ne
14d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14d2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14d3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14d5 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
14d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
14da : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14dc : 48              >            pha         ;use stack to load status
14dd : 28              >            plp
                        
14de : a0c3                     ldy #$c3  
14e0 : 08                       php
14e1 : cc0802                   cpy abs1    ;test result
                                trap_ne
14e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14e6 : 68                       pla         ;load status
                                eor_flag 0
14e7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14e9 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
14ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14ee : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14f0 : 48              >            pha         ;use stack to load status
14f1 : 28              >            plp
                        
14f2 : a082                     ldy #$82
14f4 : 08                       php
14f5 : cc0902                   cpy abs1+1  ;test result
                                trap_ne
14f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14fa : 68                       pla         ;load status
                                eor_flag 0
14fb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14fd : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1500 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1502 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1504 : 48              >            pha         ;use stack to load status
1505 : 28              >            plp
                        
1506 : a041                     ldy #$41
1508 : 08                       php
1509 : cc0a02                   cpy abs1+2  ;test result
                                trap_ne
150c : d0fe            >        bne *           ;failed not equal (non zero)
                        
150e : 68                       pla         ;load status
                                eor_flag 0
150f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1511 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1514 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1516 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1518 : 48              >            pha         ;use stack to load status
1519 : 28              >            plp
                        
151a : a000                     ldy #0
151c : 08                       php
151d : cc0b02                   cpy abs1+3  ;test result
                                trap_ne
1520 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1522 : 68                       pla         ;load status
                                eor_flag 0
1523 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1525 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1528 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
152a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
152c : 48              >            pha         ;use stack to load status
152d : 28              >            plp
                        
152e : a0c3                     ldy #$c3  
1530 : 08                       php
1531 : cc0802                   cpy abs1    ;test result
                                trap_ne
1534 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1536 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1537 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1539 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
153c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
153e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1540 : 48              >            pha         ;use stack to load status
1541 : 28              >            plp
                        
1542 : a082                     ldy #$82
1544 : 08                       php
1545 : cc0902                   cpy abs1+1  ;test result
                                trap_ne
1548 : d0fe            >        bne *           ;failed not equal (non zero)
                        
154a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
154b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
154d : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1550 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1552 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1554 : 48              >            pha         ;use stack to load status
1555 : 28              >            plp
                        
1556 : a041                     ldy #$41
1558 : 08                       php
1559 : cc0a02                   cpy abs1+2   ;test result
                                trap_ne
155c : d0fe            >        bne *           ;failed not equal (non zero)
                        
155e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
155f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1561 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1564 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1566 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1568 : 48              >            pha         ;use stack to load status
1569 : 28              >            plp
                        
156a : a000                     ldy #0
156c : 08                       php
156d : cc0b02                   cpy abs1+3  ;test result
                                trap_ne
1570 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1572 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1573 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1575 : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1578 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
157a : a000                     ldy #0
157c : a50c                     lda zpt  
157e : 49c3                     eor #$c3
1580 : c513                     cmp zp1  
                                trap_ne     ;store to zp   data
1582 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1584 : 840c                     sty zpt     ;clear                
1586 : ad0302                   lda abst  
1589 : 49c3                     eor #$c3
158b : cd0802                   cmp abs1  
                                trap_ne     ;store to abs   data
158e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1590 : 8c0302                   sty abst    ;clear                
1593 : a50d                     lda zpt+1
1595 : 49c3                     eor #$c3
1597 : c514                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
1599 : d0fe            >        bne *           ;failed not equal (non zero)
                        
159b : 840d                     sty zpt+1   ;clear                
159d : ad0402                   lda abst+1
15a0 : 49c3                     eor #$c3
15a2 : cd0902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
15a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a7 : 8c0402                   sty abst+1  ;clear                
15aa : a50e                     lda zpt+2
15ac : 49c3                     eor #$c3
15ae : c515                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
15b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15b2 : 840e                     sty zpt+2   ;clear                
15b4 : ad0502                   lda abst+2
15b7 : 49c3                     eor #$c3
15b9 : cd0a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
15bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
15be : 8c0502                   sty abst+2  ;clear                
15c1 : a50f                     lda zpt+3
15c3 : 49c3                     eor #$c3
15c5 : c516                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
15c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15c9 : 840f                     sty zpt+3   ;clear                
15cb : ad0602                   lda abst+3
15ce : 49c3                     eor #$c3
15d0 : cd0b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
15d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15d5 : 8c0602                   sty abst+3  ;clear                
                                next_test
15d8 : ad0002          >            lda test_case   ;previous test
15db : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
15dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
15df : a915            >            lda #test_num   ;*** next tests' number
15e1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
15e4 : a203                     ldx #3
15e6 :                  tldax    
                                set_stat 0
                       >            load_flag 0
15e6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
15e8 : 48              >            pha         ;use stack to load status
15e9 : 28              >            plp
                        
15ea : b513                     lda zp1,x
15ec : 08                       php         ;test stores do not alter flags
15ed : 49c3                     eor #$c3
15ef : 28                       plp
15f0 : 9d0302                   sta abst,x
15f3 : 08                       php         ;flags after load/store sequence
15f4 : 49c3                     eor #$c3
15f6 : dd0802                   cmp abs1,x  ;test result
                                trap_ne
15f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15fb : 68                       pla         ;load status
                                eor_flag 0
15fc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
15fe : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1601 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1603 : ca                       dex
1604 : 10e0                     bpl tldax                  
                        
1606 : a203                     ldx #3
1608 :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
1608 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
160a : 48              >            pha         ;use stack to load status
160b : 28              >            plp
                        
160c : b513                     lda zp1,x
160e : 08                       php         ;test stores do not alter flags
160f : 49c3                     eor #$c3
1611 : 28                       plp
1612 : 9d0302                   sta abst,x
1615 : 08                       php         ;flags after load/store sequence
1616 : 49c3                     eor #$c3
1618 : dd0802                   cmp abs1,x   ;test result
                                trap_ne
161b : d0fe            >        bne *           ;failed not equal (non zero)
                        
161d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
161e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1620 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1623 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1625 : ca                       dex
1626 : 10e0                     bpl tldax1                  
                        
1628 : a203                     ldx #3
162a :                  tldax2   
                                set_stat 0
                       >            load_flag 0
162a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
162c : 48              >            pha         ;use stack to load status
162d : 28              >            plp
                        
162e : bd0802                   lda abs1,x
1631 : 08                       php         ;test stores do not alter flags
1632 : 49c3                     eor #$c3
1634 : 28                       plp
1635 : 950c                     sta zpt,x
1637 : 08                       php         ;flags after load/store sequence
1638 : 49c3                     eor #$c3
163a : d513                     cmp zp1,x   ;test result
                                trap_ne
163c : d0fe            >        bne *           ;failed not equal (non zero)
                        
163e : 68                       pla         ;load status
                                eor_flag 0
163f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1641 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1644 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1646 : ca                       dex
1647 : 10e1                     bpl tldax2                  
                        
1649 : a203                     ldx #3
164b :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
164b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
164d : 48              >            pha         ;use stack to load status
164e : 28              >            plp
                        
164f : bd0802                   lda abs1,x
1652 : 08                       php         ;test stores do not alter flags
1653 : 49c3                     eor #$c3
1655 : 28                       plp
1656 : 950c                     sta zpt,x
1658 : 08                       php         ;flags after load/store sequence
1659 : 49c3                     eor #$c3
165b : d513                     cmp zp1,x   ;test result
                                trap_ne
165d : d0fe            >        bne *           ;failed not equal (non zero)
                        
165f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1660 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1662 : dd0d02                   cmp fLDx,x  ;test flags
                                trap_ne
1665 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1667 : ca                       dex
1668 : 10e1                     bpl tldax3
                        
166a : a203                     ldx #3      ;testing store result
166c : a000                     ldy #0
166e : b50c             tstax   lda zpt,x
1670 : 49c3                     eor #$c3
1672 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1674 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1676 : 940c                     sty zpt,x   ;clear                
1678 : bd0302                   lda abst,x
167b : 49c3                     eor #$c3
167d : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1680 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1682 : 8a                       txa
1683 : 9d0302                   sta abst,x  ;clear                
1686 : ca                       dex
1687 : 10e5                     bpl tstax
                                next_test
1689 : ad0002          >            lda test_case   ;previous test
168c : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
168e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
1690 : a916            >            lda #test_num   ;*** next tests' number
1692 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
1695 : a003                     ldy #3
1697 :                  tlday    
                                set_stat 0
                       >            load_flag 0
1697 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1699 : 48              >            pha         ;use stack to load status
169a : 28              >            plp
                        
169b : b124                     lda (ind1),y
169d : 08                       php         ;test stores do not alter flags
169e : 49c3                     eor #$c3
16a0 : 28                       plp
16a1 : 990302                   sta abst,y
16a4 : 08                       php         ;flags after load/store sequence
16a5 : 49c3                     eor #$c3
16a7 : d90802                   cmp abs1,y  ;test result
                                trap_ne
16aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ac : 68                       pla         ;load status
                                eor_flag 0
16ad : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
16af : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
16b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b4 : 88                       dey
16b5 : 10e0                     bpl tlday                  
                        
16b7 : a003                     ldy #3
16b9 :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
16b9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16bb : 48              >            pha         ;use stack to load status
16bc : 28              >            plp
                        
16bd : b124                     lda (ind1),y
16bf : 08                       php         ;test stores do not alter flags
16c0 : 49c3                     eor #$c3
16c2 : 28                       plp
16c3 : 990302                   sta abst,y
16c6 : 08                       php         ;flags after load/store sequence
16c7 : 49c3                     eor #$c3
16c9 : d90802                   cmp abs1,y  ;test result
                                trap_ne
16cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ce : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16cf : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16d1 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
16d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16d6 : 88                       dey
16d7 : 10e0                     bpl tlday1                  
                        
16d9 : a003                     ldy #3      ;testing store result
16db : a200                     ldx #0
16dd : b90302           tstay   lda abst,y
16e0 : 49c3                     eor #$c3
16e2 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
16e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e7 : 8a                       txa
16e8 : 990302                   sta abst,y  ;clear                
16eb : 88                       dey
16ec : 10ef                     bpl tstay
                        
16ee : a003                     ldy #3
16f0 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
16f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
16f2 : 48              >            pha         ;use stack to load status
16f3 : 28              >            plp
                        
16f4 : b90802                   lda abs1,y
16f7 : 08                       php         ;test stores do not alter flags
16f8 : 49c3                     eor #$c3
16fa : 28                       plp
16fb : 9130                     sta (indt),y
16fd : 08                       php         ;flags after load/store sequence
16fe : 49c3                     eor #$c3
1700 : d124                     cmp (ind1),y    ;test result
                                trap_ne
1702 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1704 : 68                       pla         ;load status
                                eor_flag 0
1705 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1707 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
170a : d0fe            >        bne *           ;failed not equal (non zero)
                        
170c : 88                       dey
170d : 10e1                     bpl tlday2                  
                        
170f : a003                     ldy #3
1711 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1711 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1713 : 48              >            pha         ;use stack to load status
1714 : 28              >            plp
                        
1715 : b90802                   lda abs1,y
1718 : 08                       php         ;test stores do not alter flags
1719 : 49c3                     eor #$c3
171b : 28                       plp
171c : 9130                     sta (indt),y
171e : 08                       php         ;flags after load/store sequence
171f : 49c3                     eor #$c3
1721 : d124                     cmp (ind1),y   ;test result
                                trap_ne
1723 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1725 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1726 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1728 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
172b : d0fe            >        bne *           ;failed not equal (non zero)
                        
172d : 88                       dey
172e : 10e1                     bpl tlday3
                                
1730 : a003                     ldy #3      ;testing store result
1732 : a200                     ldx #0
1734 : b90302           tstay1  lda abst,y
1737 : 49c3                     eor #$c3
1739 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
173c : d0fe            >        bne *           ;failed not equal (non zero)
                        
173e : 8a                       txa
173f : 990302                   sta abst,y  ;clear                
1742 : 88                       dey
1743 : 10ef                     bpl tstay1
                                
1745 : a206                     ldx #6
1747 : a003                     ldy #3
1749 :                  tldax4   
                                set_stat 0
                       >            load_flag 0
1749 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
174b : 48              >            pha         ;use stack to load status
174c : 28              >            plp
                        
174d : a124                     lda (ind1,x)
174f : 08                       php         ;test stores do not alter flags
1750 : 49c3                     eor #$c3
1752 : 28                       plp
1753 : 8130                     sta (indt,x)
1755 : 08                       php         ;flags after load/store sequence
1756 : 49c3                     eor #$c3
1758 : d90802                   cmp abs1,y  ;test result
                                trap_ne
175b : d0fe            >        bne *           ;failed not equal (non zero)
                        
175d : 68                       pla         ;load status
                                eor_flag 0
175e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1760 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
1763 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1765 : ca                       dex
1766 : ca                       dex
1767 : 88                       dey
1768 : 10df                     bpl tldax4                  
                        
176a : a206                     ldx #6
176c : a003                     ldy #3
176e :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
176e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1770 : 48              >            pha         ;use stack to load status
1771 : 28              >            plp
                        
1772 : a124                     lda (ind1,x)
1774 : 08                       php         ;test stores do not alter flags
1775 : 49c3                     eor #$c3
1777 : 28                       plp
1778 : 8130                     sta (indt,x)
177a : 08                       php         ;flags after load/store sequence
177b : 49c3                     eor #$c3
177d : d90802                   cmp abs1,y  ;test result
                                trap_ne
1780 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1782 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1783 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1785 : d90d02                   cmp fLDx,y  ;test flags
                                trap_ne
1788 : d0fe            >        bne *           ;failed not equal (non zero)
                        
178a : ca                       dex
178b : ca                       dex
178c : 88                       dey
178d : 10df                     bpl tldax5
                        
178f : a003                     ldy #3      ;testing store result
1791 : a200                     ldx #0
1793 : b90302           tstay2  lda abst,y
1796 : 49c3                     eor #$c3
1798 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
179b : d0fe            >        bne *           ;failed not equal (non zero)
                        
179d : 8a                       txa
179e : 990302                   sta abst,y  ;clear                
17a1 : 88                       dey
17a2 : 10ef                     bpl tstay2
                                next_test
17a4 : ad0002          >            lda test_case   ;previous test
17a7 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
17a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
17ab : a917            >            lda #test_num   ;*** next tests' number
17ad : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
17b0 : a2fd                     ldx #3+$fa
17b2 : b519             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
17b4 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
17b7 : ca                       dex
17b8 : e0fa                     cpx #$fa
17ba : b0f6                     bcs tldax6                  
17bc : a2fd                     ldx #3+$fa
17be : bd0e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
17c1 : 9512                     sta zpt-$fa&$ff,x
17c3 : ca                       dex
17c4 : e0fa                     cpx #$fa
17c6 : b0f6                     bcs tldax7
                                                  
17c8 : a203                     ldx #3      ;testing wraparound result
17ca : a000                     ldy #0
17cc : b50c             tstax1  lda zpt,x
17ce : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
17d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17d2 : 940c                     sty zpt,x   ;clear                
17d4 : bd0302                   lda abst,x
17d7 : dd0802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
17da : d0fe            >        bne *           ;failed not equal (non zero)
                        
17dc : 8a                       txa
17dd : 9d0302                   sta abst,x  ;clear                
17e0 : ca                       dex
17e1 : 10e9                     bpl tstax1
                        
17e3 : a0fb                     ldy #3+$f8
17e5 : a2fe                     ldx #6+$f8
17e7 : a12c             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
17e9 : 990b01                   sta abst-$f8,y
17ec : ca                       dex
17ed : ca                       dex
17ee : 88                       dey
17ef : c0f8                     cpy #$f8
17f1 : b0f4                     bcs tlday4
17f3 : a003                     ldy #3      ;testing wraparound result
17f5 : a200                     ldx #0
17f7 : b90302           tstay4  lda abst,y
17fa : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
17fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
17ff : 8a                       txa
1800 : 990302                   sta abst,y  ;clear                
1803 : 88                       dey
1804 : 10f1                     bpl tstay4
                                
1806 : a0fb                     ldy #3+$f8
1808 : b91001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
180b : 9138                     sta (inwt),y
180d : 88                       dey
180e : c0f8                     cpy #$f8
1810 : b0f6                     bcs tlday5                  
1812 : a003                     ldy #3      ;testing wraparound result
1814 : a200                     ldx #0
1816 : b90302           tstay5  lda abst,y
1819 : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
181c : d0fe            >        bne *           ;failed not equal (non zero)
                        
181e : 8a                       txa
181f : 990302                   sta abst,y  ;clear                
1822 : 88                       dey
1823 : 10f1                     bpl tstay5
                        
1825 : a0fb                     ldy #3+$f8
1827 : a2fe                     ldx #6+$f8
1829 : b12e             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
182b : 8138                     sta (indt-$f8&$ff,x)
182d : ca                       dex
182e : ca                       dex
182f : 88                       dey
1830 : c0f8                     cpy #$f8
1832 : b0f5                     bcs tlday6
1834 : a003                     ldy #3      ;testing wraparound result
1836 : a200                     ldx #0
1838 : b90302           tstay6  lda abst,y
183b : d90802                   cmp abs1,y
                                trap_ne     ;store to abs data
183e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1840 : 8a                       txa
1841 : 990302                   sta abst,y  ;clear                
1844 : 88                       dey
1845 : 10f1                     bpl tstay6
                                next_test
1847 : ad0002          >            lda test_case   ;previous test
184a : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
184c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
184e : a918            >            lda #test_num   ;*** next tests' number
1850 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1853 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1855 : 48              >            pha         ;use stack to load status
1856 : 28              >            plp
                        
1857 : a513                     lda zp1
1859 : 08                       php         ;test stores do not alter flags
185a : 49c3                     eor #$c3
185c : 28                       plp
185d : 8d0302                   sta abst
1860 : 08                       php         ;flags after load/store sequence
1861 : 49c3                     eor #$c3
1863 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1865 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1867 : 68                       pla         ;load status
                                eor_flag 0
1868 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
186a : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
186d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
186f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1871 : 48              >            pha         ;use stack to load status
1872 : 28              >            plp
                        
1873 : a514                     lda zp1+1
1875 : 08                       php         ;test stores do not alter flags
1876 : 49c3                     eor #$c3
1878 : 28                       plp
1879 : 8d0402                   sta abst+1
187c : 08                       php         ;flags after load/store sequence
187d : 49c3                     eor #$c3
187f : c982                     cmp #$82    ;test result
                                trap_ne
1881 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1883 : 68                       pla         ;load status
                                eor_flag 0
1884 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1886 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1889 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
188b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
188d : 48              >            pha         ;use stack to load status
188e : 28              >            plp
                        
188f : a515                     lda zp1+2
1891 : 08                       php         ;test stores do not alter flags
1892 : 49c3                     eor #$c3
1894 : 28                       plp
1895 : 8d0502                   sta abst+2
1898 : 08                       php         ;flags after load/store sequence
1899 : 49c3                     eor #$c3
189b : c941                     cmp #$41    ;test result
                                trap_ne
189d : d0fe            >        bne *           ;failed not equal (non zero)
                        
189f : 68                       pla         ;load status
                                eor_flag 0
18a0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18a2 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
18a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18a7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18a9 : 48              >            pha         ;use stack to load status
18aa : 28              >            plp
                        
18ab : a516                     lda zp1+3
18ad : 08                       php         ;test stores do not alter flags
18ae : 49c3                     eor #$c3
18b0 : 28                       plp
18b1 : 8d0602                   sta abst+3
18b4 : 08                       php         ;flags after load/store sequence
18b5 : 49c3                     eor #$c3
18b7 : c900                     cmp #0      ;test result
                                trap_ne
18b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18bb : 68                       pla         ;load status
                                eor_flag 0
18bc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18be : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
18c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18c3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18c5 : 48              >            pha         ;use stack to load status
18c6 : 28              >            plp
                        
18c7 : a513                     lda zp1  
18c9 : 08                       php         ;test stores do not alter flags
18ca : 49c3                     eor #$c3
18cc : 28                       plp
18cd : 8d0302                   sta abst  
18d0 : 08                       php         ;flags after load/store sequence
18d1 : 49c3                     eor #$c3
18d3 : c9c3                     cmp #$c3    ;test result
                                trap_ne
18d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18d7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18d8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18da : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
18dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18e1 : 48              >            pha         ;use stack to load status
18e2 : 28              >            plp
                        
18e3 : a514                     lda zp1+1
18e5 : 08                       php         ;test stores do not alter flags
18e6 : 49c3                     eor #$c3
18e8 : 28                       plp
18e9 : 8d0402                   sta abst+1
18ec : 08                       php         ;flags after load/store sequence
18ed : 49c3                     eor #$c3
18ef : c982                     cmp #$82    ;test result
                                trap_ne
18f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18f3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18f4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18f6 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
18f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18fb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18fd : 48              >            pha         ;use stack to load status
18fe : 28              >            plp
                        
18ff : a515                     lda zp1+2
1901 : 08                       php         ;test stores do not alter flags
1902 : 49c3                     eor #$c3
1904 : 28                       plp
1905 : 8d0502                   sta abst+2
1908 : 08                       php         ;flags after load/store sequence
1909 : 49c3                     eor #$c3
190b : c941                     cmp #$41    ;test result
                                trap_ne
190d : d0fe            >        bne *           ;failed not equal (non zero)
                        
190f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1910 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1912 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1915 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1917 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1919 : 48              >            pha         ;use stack to load status
191a : 28              >            plp
                        
191b : a516                     lda zp1+3
191d : 08                       php         ;test stores do not alter flags
191e : 49c3                     eor #$c3
1920 : 28                       plp
1921 : 8d0602                   sta abst+3
1924 : 08                       php         ;flags after load/store sequence
1925 : 49c3                     eor #$c3
1927 : c900                     cmp #0      ;test result
                                trap_ne
1929 : d0fe            >        bne *           ;failed not equal (non zero)
                        
192b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
192c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
192e : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1931 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1933 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1935 : 48              >            pha         ;use stack to load status
1936 : 28              >            plp
                        
1937 : ad0802                   lda abs1  
193a : 08                       php         ;test stores do not alter flags
193b : 49c3                     eor #$c3
193d : 28                       plp
193e : 850c                     sta zpt  
1940 : 08                       php         ;flags after load/store sequence
1941 : 49c3                     eor #$c3
1943 : c513                     cmp zp1     ;test result
                                trap_ne
1945 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1947 : 68                       pla         ;load status
                                eor_flag 0
1948 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
194a : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
194d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
194f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1951 : 48              >            pha         ;use stack to load status
1952 : 28              >            plp
                        
1953 : ad0902                   lda abs1+1
1956 : 08                       php         ;test stores do not alter flags
1957 : 49c3                     eor #$c3
1959 : 28                       plp
195a : 850d                     sta zpt+1
195c : 08                       php         ;flags after load/store sequence
195d : 49c3                     eor #$c3
195f : c514                     cmp zp1+1   ;test result
                                trap_ne
1961 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1963 : 68                       pla         ;load status
                                eor_flag 0
1964 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1966 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1969 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
196b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
196d : 48              >            pha         ;use stack to load status
196e : 28              >            plp
                        
196f : ad0a02                   lda abs1+2
1972 : 08                       php         ;test stores do not alter flags
1973 : 49c3                     eor #$c3
1975 : 28                       plp
1976 : 850e                     sta zpt+2
1978 : 08                       php         ;flags after load/store sequence
1979 : 49c3                     eor #$c3
197b : c515                     cmp zp1+2   ;test result
                                trap_ne
197d : d0fe            >        bne *           ;failed not equal (non zero)
                        
197f : 68                       pla         ;load status
                                eor_flag 0
1980 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1982 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1985 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1987 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1989 : 48              >            pha         ;use stack to load status
198a : 28              >            plp
                        
198b : ad0b02                   lda abs1+3
198e : 08                       php         ;test stores do not alter flags
198f : 49c3                     eor #$c3
1991 : 28                       plp
1992 : 850f                     sta zpt+3
1994 : 08                       php         ;flags after load/store sequence
1995 : 49c3                     eor #$c3
1997 : c516                     cmp zp1+3   ;test result
                                trap_ne
1999 : d0fe            >        bne *           ;failed not equal (non zero)
                        
199b : 68                       pla         ;load status
                                eor_flag 0
199c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
199e : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
19a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19a3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19a5 : 48              >            pha         ;use stack to load status
19a6 : 28              >            plp
                        
19a7 : ad0802                   lda abs1  
19aa : 08                       php         ;test stores do not alter flags
19ab : 49c3                     eor #$c3
19ad : 28                       plp
19ae : 850c                     sta zpt  
19b0 : 08                       php         ;flags after load/store sequence
19b1 : 49c3                     eor #$c3
19b3 : c513                     cmp zp1     ;test result
                                trap_ne
19b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19b7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19b8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19ba : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
19bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19bf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19c1 : 48              >            pha         ;use stack to load status
19c2 : 28              >            plp
                        
19c3 : ad0902                   lda abs1+1
19c6 : 08                       php         ;test stores do not alter flags
19c7 : 49c3                     eor #$c3
19c9 : 28                       plp
19ca : 850d                     sta zpt+1
19cc : 08                       php         ;flags after load/store sequence
19cd : 49c3                     eor #$c3
19cf : c514                     cmp zp1+1   ;test result
                                trap_ne
19d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19d3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19d4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19d6 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
19d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19db : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19dd : 48              >            pha         ;use stack to load status
19de : 28              >            plp
                        
19df : ad0a02                   lda abs1+2
19e2 : 08                       php         ;test stores do not alter flags
19e3 : 49c3                     eor #$c3
19e5 : 28                       plp
19e6 : 850e                     sta zpt+2
19e8 : 08                       php         ;flags after load/store sequence
19e9 : 49c3                     eor #$c3
19eb : c515                     cmp zp1+2   ;test result
                                trap_ne
19ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ef : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19f0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19f2 : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
19f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19f7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19f9 : 48              >            pha         ;use stack to load status
19fa : 28              >            plp
                        
19fb : ad0b02                   lda abs1+3
19fe : 08                       php         ;test stores do not alter flags
19ff : 49c3                     eor #$c3
1a01 : 28                       plp
1a02 : 850f                     sta zpt+3
1a04 : 08                       php         ;flags after load/store sequence
1a05 : 49c3                     eor #$c3
1a07 : c516                     cmp zp1+3   ;test result
                                trap_ne
1a09 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a0b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a0c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a0e : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1a11 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a13 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1a15 : 48              >            pha         ;use stack to load status
1a16 : 28              >            plp
                        
1a17 : a9c3                     lda #$c3
1a19 : 08                       php
1a1a : cd0802                   cmp abs1    ;test result
                                trap_ne
1a1d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a1f : 68                       pla         ;load status
                                eor_flag 0
1a20 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a22 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1a25 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a27 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a29 : 48              >            pha         ;use stack to load status
1a2a : 28              >            plp
                        
1a2b : a982                     lda #$82
1a2d : 08                       php
1a2e : cd0902                   cmp abs1+1  ;test result
                                trap_ne
1a31 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a33 : 68                       pla         ;load status
                                eor_flag 0
1a34 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a36 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a39 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a3b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a3d : 48              >            pha         ;use stack to load status
1a3e : 28              >            plp
                        
1a3f : a941                     lda #$41
1a41 : 08                       php
1a42 : cd0a02                   cmp abs1+2  ;test result
                                trap_ne
1a45 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a47 : 68                       pla         ;load status
                                eor_flag 0
1a48 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a4a : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a4d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a4f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a51 : 48              >            pha         ;use stack to load status
1a52 : 28              >            plp
                        
1a53 : a900                     lda #0
1a55 : 08                       php
1a56 : cd0b02                   cmp abs1+3  ;test result
                                trap_ne
1a59 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a5b : 68                       pla         ;load status
                                eor_flag 0
1a5c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a5e : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1a61 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1a63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a65 : 48              >            pha         ;use stack to load status
1a66 : 28              >            plp
                        
1a67 : a9c3                     lda #$c3  
1a69 : 08                       php
1a6a : cd0802                   cmp abs1    ;test result
                                trap_ne
1a6d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a6f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a70 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a72 : cd0d02                   cmp fLDx    ;test flags
                                trap_ne
1a75 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a77 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a79 : 48              >            pha         ;use stack to load status
1a7a : 28              >            plp
                        
1a7b : a982                     lda #$82
1a7d : 08                       php
1a7e : cd0902                   cmp abs1+1  ;test result
                                trap_ne
1a81 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a83 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a84 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a86 : cd0e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a89 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a8b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a8d : 48              >            pha         ;use stack to load status
1a8e : 28              >            plp
                        
1a8f : a941                     lda #$41
1a91 : 08                       php
1a92 : cd0a02                   cmp abs1+2  ;test result
                                trap_ne
1a95 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a97 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a98 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a9a : cd0f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a9d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a9f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aa1 : 48              >            pha         ;use stack to load status
1aa2 : 28              >            plp
                        
1aa3 : a900                     lda #0
1aa5 : 08                       php
1aa6 : cd0b02                   cmp abs1+3  ;test result
                                trap_ne
1aa9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aab : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1aac : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1aae : cd1002                   cmp fLDx+3  ;test flags
                                trap_ne
1ab1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1ab3 : a200                     ldx #0
1ab5 : a50c                     lda zpt  
1ab7 : 49c3                     eor #$c3
1ab9 : c513                     cmp zp1  
                                trap_ne     ;store to zp data
1abb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1abd : 860c                     stx zpt     ;clear                
1abf : ad0302                   lda abst  
1ac2 : 49c3                     eor #$c3
1ac4 : cd0802                   cmp abs1  
                                trap_ne     ;store to abs data
1ac7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ac9 : 8e0302                   stx abst    ;clear                
1acc : a50d                     lda zpt+1
1ace : 49c3                     eor #$c3
1ad0 : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
1ad2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ad4 : 860d                     stx zpt+1   ;clear                
1ad6 : ad0402                   lda abst+1
1ad9 : 49c3                     eor #$c3
1adb : cd0902                   cmp abs1+1
                                trap_ne     ;store to abs data
1ade : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ae0 : 8e0402                   stx abst+1  ;clear                
1ae3 : a50e                     lda zpt+2
1ae5 : 49c3                     eor #$c3
1ae7 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
1ae9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aeb : 860e                     stx zpt+2   ;clear                
1aed : ad0502                   lda abst+2
1af0 : 49c3                     eor #$c3
1af2 : cd0a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1af5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1af7 : 8e0502                   stx abst+2  ;clear                
1afa : a50f                     lda zpt+3
1afc : 49c3                     eor #$c3
1afe : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
1b00 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b02 : 860f                     stx zpt+3   ;clear                
1b04 : ad0602                   lda abst+3
1b07 : 49c3                     eor #$c3
1b09 : cd0b02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b0c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b0e : 8e0602                   stx abst+3  ;clear                
                                next_test
1b11 : ad0002          >            lda test_case   ;previous test
1b14 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b18 : a919            >            lda #test_num   ;*** next tests' number
1b1a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1b1d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b1f : 48              >            pha         ;use stack to load status
1b20 : a9ff            >            lda #$ff     ;precharge accu
1b22 : 28              >            plp
                        
1b23 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b25 : 08              >            php         ;save flags
1b26 : 08              >            php
1b27 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b2b : 68              >            pla         ;load status
                       >            cmp_flag fz 
1b2c : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b30 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b31 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b33 : 48              >            pha         ;use stack to load status
1b34 : a901            >            lda #1     ;precharge accu
1b36 : 28              >            plp
                        
1b37 : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b39 : 08              >            php         ;save flags
1b3a : 08              >            php
1b3b : c901            >            cmp #1     ;test result
                       >            trap_ne
1b3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b3f : 68              >            pla         ;load status
                       >            cmp_flag fv
1b40 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b44 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b45 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b47 : 48              >            pha         ;use stack to load status
1b48 : a901            >            lda #1     ;precharge accu
1b4a : 28              >            plp
                        
1b4b : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b4d : 08              >            php         ;save flags
1b4e : 08              >            php
1b4f : c901            >            cmp #1     ;test result
                       >            trap_ne
1b51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b53 : 68              >            pla         ;load status
                       >            cmp_flag fnz
1b54 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b58 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b59 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b5b : 48              >            pha         ;use stack to load status
1b5c : a901            >            lda #1     ;precharge accu
1b5e : 28              >            plp
                        
1b5f : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b61 : 08              >            php         ;save flags
1b62 : 08              >            php
1b63 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b67 : 68              >            pla         ;load status
                       >            cmp_flag fnv
1b68 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b6c : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b6d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b6f : 48              >            pha         ;use stack to load status
1b70 : a9ff            >            lda #$ff     ;precharge accu
1b72 : 28              >            plp
                        
1b73 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1b75 : 08              >            php         ;save flags
1b76 : 08              >            php
1b77 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b7b : 68              >            pla         ;load status
                       >            cmp_flag ~fnv 
1b7c : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b80 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b81 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b83 : 48              >            pha         ;use stack to load status
1b84 : a901            >            lda #1     ;precharge accu
1b86 : 28              >            plp
                        
1b87 : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1b89 : 08              >            php         ;save flags
1b8a : 08              >            php
1b8b : c901            >            cmp #1     ;test result
                       >            trap_ne
1b8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b8f : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
1b90 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b94 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b95 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b97 : 48              >            pha         ;use stack to load status
1b98 : a901            >            lda #1     ;precharge accu
1b9a : 28              >            plp
                        
1b9b : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1b9d : 08              >            php         ;save flags
1b9e : 08              >            php
1b9f : c901            >            cmp #1     ;test result
                       >            trap_ne
1ba1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba3 : 68              >            pla         ;load status
                       >            cmp_flag ~fv
1ba4 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ba6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba8 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1ba9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bab : 48              >            pha         ;use stack to load status
1bac : a901            >            lda #1     ;precharge accu
1bae : 28              >            plp
                        
1baf : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1bb1 : 08              >            php         ;save flags
1bb2 : 08              >            php
1bb3 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bb7 : 68              >            pla         ;load status
                       >            cmp_flag ~fz
1bb8 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bbc : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1bbd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bbf : 48              >            pha         ;use stack to load status
1bc0 : a9ff            >            lda #$ff     ;precharge accu
1bc2 : 28              >            plp
                        
1bc3 : 2c0b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1bc6 : 08              >            php         ;save flags
1bc7 : 08              >            php
1bc8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bcc : 68              >            pla         ;load status
                       >            cmp_flag fz 
1bcd : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd1 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bd2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bd4 : 48              >            pha         ;use stack to load status
1bd5 : a901            >            lda #1     ;precharge accu
1bd7 : 28              >            plp
                        
1bd8 : 2c0a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1bdb : 08              >            php         ;save flags
1bdc : 08              >            php
1bdd : c901            >            cmp #1     ;test result
                       >            trap_ne
1bdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be1 : 68              >            pla         ;load status
                       >            cmp_flag fv
1be2 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1be4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be6 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1be7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1be9 : 48              >            pha         ;use stack to load status
1bea : a901            >            lda #1     ;precharge accu
1bec : 28              >            plp
                        
1bed : 2c0902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1bf0 : 08              >            php         ;save flags
1bf1 : 08              >            php
1bf2 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bf4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bf6 : 68              >            pla         ;load status
                       >            cmp_flag fnz
1bf7 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bf9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bfb : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bfc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bfe : 48              >            pha         ;use stack to load status
1bff : a901            >            lda #1     ;precharge accu
1c01 : 28              >            plp
                        
1c02 : 2c0802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c05 : 08              >            php         ;save flags
1c06 : 08              >            php
1c07 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c0b : 68              >            pla         ;load status
                       >            cmp_flag fnv
1c0c : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c10 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c11 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c13 : 48              >            pha         ;use stack to load status
1c14 : a9ff            >            lda #$ff     ;precharge accu
1c16 : 28              >            plp
                        
1c17 : 2c0b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c1a : 08              >            php         ;save flags
1c1b : 08              >            php
1c1c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c20 : 68              >            pla         ;load status
                       >            cmp_flag ~fnv 
1c21 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c25 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c26 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c28 : 48              >            pha         ;use stack to load status
1c29 : a901            >            lda #1     ;precharge accu
1c2b : 28              >            plp
                        
1c2c : 2c0a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c2f : 08              >            php         ;save flags
1c30 : 08              >            php
1c31 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c35 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
1c36 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3a : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c3b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c3d : 48              >            pha         ;use stack to load status
1c3e : a901            >            lda #1     ;precharge accu
1c40 : 28              >            plp
                        
1c41 : 2c0902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c44 : 08              >            php         ;save flags
1c45 : 08              >            php
1c46 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c4a : 68              >            pla         ;load status
                       >            cmp_flag ~fv
1c4b : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c4f : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c50 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c52 : 48              >            pha         ;use stack to load status
1c53 : a901            >            lda #1     ;precharge accu
1c55 : 28              >            plp
                        
1c56 : 2c0802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c59 : 08              >            php         ;save flags
1c5a : 08              >            php
1c5b : c901            >            cmp #1     ;test result
                       >            trap_ne
1c5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c5f : 68              >            pla         ;load status
                       >            cmp_flag ~fz
1c60 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c64 : 28              >            plp         ;restore status
                        
                                next_test
1c65 : ad0002          >            lda test_case   ;previous test
1c68 : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1c6c : a91a            >            lda #test_num   ;*** next tests' number
1c6e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1c71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c73 : 48              >            pha         ;use stack to load status
1c74 : a280            >            ldx #$80     ;precharge index x
1c76 : 28              >            plp
                        
1c77 : e417                     cpx zp7f
                                tst_stat fc
1c79 : 08              >            php         ;save status
1c7a : 08              >            php         ;use stack to retrieve status
1c7b : 68              >            pla
                       >            cmp_flag fc
1c7c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c80 : 28              >            plp         ;restore status
                        
1c81 : ca                       dex
1c82 : e417                     cpx zp7f
                                tst_stat fzc
1c84 : 08              >            php         ;save status
1c85 : 08              >            php         ;use stack to retrieve status
1c86 : 68              >            pla
                       >            cmp_flag fzc
1c87 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c8b : 28              >            plp         ;restore status
                        
1c8c : ca                       dex
1c8d : e417                     cpx zp7f
                                tst_x $7e,fn
1c8f : 08              >            php         ;save flags
1c90 : 08              >            php
1c91 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c95 : 68              >            pla         ;load status
                       >            cmp_flag fn
1c96 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c9a : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1c9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c9d : 48              >            pha         ;use stack to load status
1c9e : a280            >            ldx #$80     ;precharge index x
1ca0 : 28              >            plp
                        
1ca1 : e417                     cpx zp7f
                                tst_stat ~fnz
1ca3 : 08              >            php         ;save status
1ca4 : 08              >            php         ;use stack to retrieve status
1ca5 : 68              >            pla
                       >            cmp_flag ~fnz
1ca6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ca8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1caa : 28              >            plp         ;restore status
                        
1cab : ca                       dex
1cac : e417                     cpx zp7f
                                tst_stat ~fn
1cae : 08              >            php         ;save status
1caf : 08              >            php         ;use stack to retrieve status
1cb0 : 68              >            pla
                       >            cmp_flag ~fn
1cb1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cb5 : 28              >            plp         ;restore status
                        
1cb6 : ca                       dex
1cb7 : e417                     cpx zp7f
                                tst_x $7e,~fzc
1cb9 : 08              >            php         ;save flags
1cba : 08              >            php
1cbb : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cbf : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1cc0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc4 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1cc5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cc7 : 48              >            pha         ;use stack to load status
1cc8 : a280            >            ldx #$80     ;precharge index x
1cca : 28              >            plp
                        
1ccb : ec0c02                   cpx abs7f
                                tst_stat fc
1cce : 08              >            php         ;save status
1ccf : 08              >            php         ;use stack to retrieve status
1cd0 : 68              >            pla
                       >            cmp_flag fc
1cd1 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd5 : 28              >            plp         ;restore status
                        
1cd6 : ca                       dex
1cd7 : ec0c02                   cpx abs7f
                                tst_stat fzc
1cda : 08              >            php         ;save status
1cdb : 08              >            php         ;use stack to retrieve status
1cdc : 68              >            pla
                       >            cmp_flag fzc
1cdd : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce1 : 28              >            plp         ;restore status
                        
1ce2 : ca                       dex
1ce3 : ec0c02                   cpx abs7f
                                tst_x $7e,fn
1ce6 : 08              >            php         ;save flags
1ce7 : 08              >            php
1ce8 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cec : 68              >            pla         ;load status
                       >            cmp_flag fn
1ced : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf1 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1cf2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cf4 : 48              >            pha         ;use stack to load status
1cf5 : a280            >            ldx #$80     ;precharge index x
1cf7 : 28              >            plp
                        
1cf8 : ec0c02                   cpx abs7f
                                tst_stat ~fnz
1cfb : 08              >            php         ;save status
1cfc : 08              >            php         ;use stack to retrieve status
1cfd : 68              >            pla
                       >            cmp_flag ~fnz
1cfe : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d02 : 28              >            plp         ;restore status
                        
1d03 : ca                       dex
1d04 : ec0c02                   cpx abs7f
                                tst_stat ~fn
1d07 : 08              >            php         ;save status
1d08 : 08              >            php         ;use stack to retrieve status
1d09 : 68              >            pla
                       >            cmp_flag ~fn
1d0a : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d0e : 28              >            plp         ;restore status
                        
1d0f : ca                       dex
1d10 : ec0c02                   cpx abs7f
                                tst_x $7e,~fzc
1d13 : 08              >            php         ;save flags
1d14 : 08              >            php
1d15 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d19 : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1d1a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1e : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d1f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d21 : 48              >            pha         ;use stack to load status
1d22 : a280            >            ldx #$80     ;precharge index x
1d24 : 28              >            plp
                        
1d25 : e07f                     cpx #$7f
                                tst_stat fc
1d27 : 08              >            php         ;save status
1d28 : 08              >            php         ;use stack to retrieve status
1d29 : 68              >            pla
                       >            cmp_flag fc
1d2a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d2e : 28              >            plp         ;restore status
                        
1d2f : ca                       dex
1d30 : e07f                     cpx #$7f
                                tst_stat fzc
1d32 : 08              >            php         ;save status
1d33 : 08              >            php         ;use stack to retrieve status
1d34 : 68              >            pla
                       >            cmp_flag fzc
1d35 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d39 : 28              >            plp         ;restore status
                        
1d3a : ca                       dex
1d3b : e07f                     cpx #$7f
                                tst_x $7e,fn
1d3d : 08              >            php         ;save flags
1d3e : 08              >            php
1d3f : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d43 : 68              >            pla         ;load status
                       >            cmp_flag fn
1d44 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d48 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d49 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d4b : 48              >            pha         ;use stack to load status
1d4c : a280            >            ldx #$80     ;precharge index x
1d4e : 28              >            plp
                        
1d4f : e07f                     cpx #$7f
                                tst_stat ~fnz
1d51 : 08              >            php         ;save status
1d52 : 08              >            php         ;use stack to retrieve status
1d53 : 68              >            pla
                       >            cmp_flag ~fnz
1d54 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d58 : 28              >            plp         ;restore status
                        
1d59 : ca                       dex
1d5a : e07f                     cpx #$7f
                                tst_stat ~fn
1d5c : 08              >            php         ;save status
1d5d : 08              >            php         ;use stack to retrieve status
1d5e : 68              >            pla
                       >            cmp_flag ~fn
1d5f : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d63 : 28              >            plp         ;restore status
                        
1d64 : ca                       dex
1d65 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1d67 : 08              >            php         ;save flags
1d68 : 08              >            php
1d69 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d6d : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1d6e : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d72 : 28              >            plp         ;restore status
                        
                                next_test
1d73 : ad0002          >            lda test_case   ;previous test
1d76 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1d78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1d7a : a91b            >            lda #test_num   ;*** next tests' number
1d7c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1d7f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d81 : 48              >            pha         ;use stack to load status
1d82 : a080            >            ldy #$80     ;precharge index y
1d84 : 28              >            plp
                        
1d85 : c417                     cpy zp7f
                                tst_stat fc
1d87 : 08              >            php         ;save status
1d88 : 08              >            php         ;use stack to retrieve status
1d89 : 68              >            pla
                       >            cmp_flag fc
1d8a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d8e : 28              >            plp         ;restore status
                        
1d8f : 88                       dey
1d90 : c417                     cpy zp7f
                                tst_stat fzc
1d92 : 08              >            php         ;save status
1d93 : 08              >            php         ;use stack to retrieve status
1d94 : 68              >            pla
                       >            cmp_flag fzc
1d95 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d97 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d99 : 28              >            plp         ;restore status
                        
1d9a : 88                       dey
1d9b : c417                     cpy zp7f
                                tst_y $7e,fn
1d9d : 08              >            php         ;save flags
1d9e : 08              >            php
1d9f : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1da1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da3 : 68              >            pla         ;load status
                       >            cmp_flag fn
1da4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1da6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da8 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1da9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1dab : 48              >            pha         ;use stack to load status
1dac : a080            >            ldy #$80     ;precharge index y
1dae : 28              >            plp
                        
1daf : c417                     cpy zp7f
                                tst_stat ~fnz
1db1 : 08              >            php         ;save status
1db2 : 08              >            php         ;use stack to retrieve status
1db3 : 68              >            pla
                       >            cmp_flag ~fnz
1db4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1db6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1db8 : 28              >            plp         ;restore status
                        
1db9 : 88                       dey
1dba : c417                     cpy zp7f
                                tst_stat ~fn
1dbc : 08              >            php         ;save status
1dbd : 08              >            php         ;use stack to retrieve status
1dbe : 68              >            pla
                       >            cmp_flag ~fn
1dbf : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc3 : 28              >            plp         ;restore status
                        
1dc4 : 88                       dey
1dc5 : c417                     cpy zp7f
                                tst_y $7e,~fzc
1dc7 : 08              >            php         ;save flags
1dc8 : 08              >            php
1dc9 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dcd : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1dce : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd2 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1dd3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dd5 : 48              >            pha         ;use stack to load status
1dd6 : a080            >            ldy #$80     ;precharge index y
1dd8 : 28              >            plp
                        
1dd9 : cc0c02                   cpy abs7f
                                tst_stat fc
1ddc : 08              >            php         ;save status
1ddd : 08              >            php         ;use stack to retrieve status
1dde : 68              >            pla
                       >            cmp_flag fc
1ddf : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1de1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de3 : 28              >            plp         ;restore status
                        
1de4 : 88                       dey
1de5 : cc0c02                   cpy abs7f
                                tst_stat fzc
1de8 : 08              >            php         ;save status
1de9 : 08              >            php         ;use stack to retrieve status
1dea : 68              >            pla
                       >            cmp_flag fzc
1deb : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ded : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1def : 28              >            plp         ;restore status
                        
1df0 : 88                       dey
1df1 : cc0c02                   cpy abs7f
                                tst_y $7e,fn
1df4 : 08              >            php         ;save flags
1df5 : 08              >            php
1df6 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1df8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dfa : 68              >            pla         ;load status
                       >            cmp_flag fn
1dfb : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dfd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dff : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e00 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e02 : 48              >            pha         ;use stack to load status
1e03 : a080            >            ldy #$80     ;precharge index y
1e05 : 28              >            plp
                        
1e06 : cc0c02                   cpy abs7f
                                tst_stat ~fnz
1e09 : 08              >            php         ;save status
1e0a : 08              >            php         ;use stack to retrieve status
1e0b : 68              >            pla
                       >            cmp_flag ~fnz
1e0c : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e10 : 28              >            plp         ;restore status
                        
1e11 : 88                       dey
1e12 : cc0c02                   cpy abs7f
                                tst_stat ~fn
1e15 : 08              >            php         ;save status
1e16 : 08              >            php         ;use stack to retrieve status
1e17 : 68              >            pla
                       >            cmp_flag ~fn
1e18 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e1c : 28              >            plp         ;restore status
                        
1e1d : 88                       dey
1e1e : cc0c02                   cpy abs7f
                                tst_y $7e,~fzc
1e21 : 08              >            php         ;save flags
1e22 : 08              >            php
1e23 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e27 : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1e28 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2c : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e2d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e2f : 48              >            pha         ;use stack to load status
1e30 : a080            >            ldy #$80     ;precharge index y
1e32 : 28              >            plp
                        
1e33 : c07f                     cpy #$7f
                                tst_stat fc
1e35 : 08              >            php         ;save status
1e36 : 08              >            php         ;use stack to retrieve status
1e37 : 68              >            pla
                       >            cmp_flag fc
1e38 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e3c : 28              >            plp         ;restore status
                        
1e3d : 88                       dey
1e3e : c07f                     cpy #$7f
                                tst_stat fzc
1e40 : 08              >            php         ;save status
1e41 : 08              >            php         ;use stack to retrieve status
1e42 : 68              >            pla
                       >            cmp_flag fzc
1e43 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e47 : 28              >            plp         ;restore status
                        
1e48 : 88                       dey
1e49 : c07f                     cpy #$7f
                                tst_y $7e,fn
1e4b : 08              >            php         ;save flags
1e4c : 08              >            php
1e4d : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e51 : 68              >            pla         ;load status
                       >            cmp_flag fn
1e52 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e56 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e57 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e59 : 48              >            pha         ;use stack to load status
1e5a : a080            >            ldy #$80     ;precharge index y
1e5c : 28              >            plp
                        
1e5d : c07f                     cpy #$7f
                                tst_stat ~fnz
1e5f : 08              >            php         ;save status
1e60 : 08              >            php         ;use stack to retrieve status
1e61 : 68              >            pla
                       >            cmp_flag ~fnz
1e62 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e66 : 28              >            plp         ;restore status
                        
1e67 : 88                       dey
1e68 : c07f                     cpy #$7f
                                tst_stat ~fn
1e6a : 08              >            php         ;save status
1e6b : 08              >            php         ;use stack to retrieve status
1e6c : 68              >            pla
                       >            cmp_flag ~fn
1e6d : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e71 : 28              >            plp         ;restore status
                        
1e72 : 88                       dey
1e73 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1e75 : 08              >            php         ;save flags
1e76 : 08              >            php
1e77 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e7b : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1e7c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e80 : 28              >            plp         ;restore status
                        
                                next_test
1e81 : ad0002          >            lda test_case   ;previous test
1e84 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1e86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1e88 : a91c            >            lda #test_num   ;*** next tests' number
1e8a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1e8d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e8f : 48              >            pha         ;use stack to load status
1e90 : a980            >            lda #$80     ;precharge accu
1e92 : 28              >            plp
                        
1e93 : c517                     cmp zp7f
                                tst_a $80,fc
1e95 : 08              >            php         ;save flags
1e96 : 08              >            php
1e97 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e99 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e9b : 68              >            pla         ;load status
                       >            cmp_flag fc
1e9c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea0 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ea1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ea3 : 48              >            pha         ;use stack to load status
1ea4 : a97f            >            lda #$7f     ;precharge accu
1ea6 : 28              >            plp
                        
1ea7 : c517                     cmp zp7f
                                tst_a $7f,fzc
1ea9 : 08              >            php         ;save flags
1eaa : 08              >            php
1eab : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ead : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eaf : 68              >            pla         ;load status
                       >            cmp_flag fzc
1eb0 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb4 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1eb5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1eb7 : 48              >            pha         ;use stack to load status
1eb8 : a97e            >            lda #$7e     ;precharge accu
1eba : 28              >            plp
                        
1ebb : c517                     cmp zp7f
                                tst_a $7e,fn
1ebd : 08              >            php         ;save flags
1ebe : 08              >            php
1ebf : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1ec1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec3 : 68              >            pla         ;load status
                       >            cmp_flag fn
1ec4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ec6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec8 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ec9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ecb : 48              >            pha         ;use stack to load status
1ecc : a980            >            lda #$80     ;precharge accu
1ece : 28              >            plp
                        
1ecf : c517                     cmp zp7f
                                tst_a $80,~fnz
1ed1 : 08              >            php         ;save flags
1ed2 : 08              >            php
1ed3 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ed5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ed7 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
1ed8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edc : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1edd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1edf : 48              >            pha         ;use stack to load status
1ee0 : a97f            >            lda #$7f     ;precharge accu
1ee2 : 28              >            plp
                        
1ee3 : c517                     cmp zp7f
                                tst_a $7f,~fn
1ee5 : 08              >            php         ;save flags
1ee6 : 08              >            php
1ee7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ee9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eeb : 68              >            pla         ;load status
                       >            cmp_flag ~fn
1eec : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef0 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1ef1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ef3 : 48              >            pha         ;use stack to load status
1ef4 : a97e            >            lda #$7e     ;precharge accu
1ef6 : 28              >            plp
                        
1ef7 : c517                     cmp zp7f
                                tst_a $7e,~fzc
1ef9 : 08              >            php         ;save flags
1efa : 08              >            php
1efb : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1efd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eff : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1f00 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f04 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f05 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f07 : 48              >            pha         ;use stack to load status
1f08 : a980            >            lda #$80     ;precharge accu
1f0a : 28              >            plp
                        
1f0b : cd0c02                   cmp abs7f
                                tst_a $80,fc
1f0e : 08              >            php         ;save flags
1f0f : 08              >            php
1f10 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f14 : 68              >            pla         ;load status
                       >            cmp_flag fc
1f15 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f19 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f1a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f1c : 48              >            pha         ;use stack to load status
1f1d : a97f            >            lda #$7f     ;precharge accu
1f1f : 28              >            plp
                        
1f20 : cd0c02                   cmp abs7f
                                tst_a $7f,fzc
1f23 : 08              >            php         ;save flags
1f24 : 08              >            php
1f25 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f29 : 68              >            pla         ;load status
                       >            cmp_flag fzc
1f2a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f2e : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f2f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f31 : 48              >            pha         ;use stack to load status
1f32 : a97e            >            lda #$7e     ;precharge accu
1f34 : 28              >            plp
                        
1f35 : cd0c02                   cmp abs7f
                                tst_a $7e,fn
1f38 : 08              >            php         ;save flags
1f39 : 08              >            php
1f3a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f3e : 68              >            pla         ;load status
                       >            cmp_flag fn
1f3f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f43 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f46 : 48              >            pha         ;use stack to load status
1f47 : a980            >            lda #$80     ;precharge accu
1f49 : 28              >            plp
                        
1f4a : cd0c02                   cmp abs7f
                                tst_a $80,~fnz
1f4d : 08              >            php         ;save flags
1f4e : 08              >            php
1f4f : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f53 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
1f54 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f58 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f59 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f5b : 48              >            pha         ;use stack to load status
1f5c : a97f            >            lda #$7f     ;precharge accu
1f5e : 28              >            plp
                        
1f5f : cd0c02                   cmp abs7f
                                tst_a $7f,~fn
1f62 : 08              >            php         ;save flags
1f63 : 08              >            php
1f64 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f68 : 68              >            pla         ;load status
                       >            cmp_flag ~fn
1f69 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6d : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f6e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f70 : 48              >            pha         ;use stack to load status
1f71 : a97e            >            lda #$7e     ;precharge accu
1f73 : 28              >            plp
                        
1f74 : cd0c02                   cmp abs7f
                                tst_a $7e,~fzc
1f77 : 08              >            php         ;save flags
1f78 : 08              >            php
1f79 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f7d : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1f7e : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f82 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f83 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f85 : 48              >            pha         ;use stack to load status
1f86 : a980            >            lda #$80     ;precharge accu
1f88 : 28              >            plp
                        
1f89 : c97f                     cmp #$7f
                                tst_a $80,fc
1f8b : 08              >            php         ;save flags
1f8c : 08              >            php
1f8d : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f91 : 68              >            pla         ;load status
                       >            cmp_flag fc
1f92 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f96 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f97 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f99 : 48              >            pha         ;use stack to load status
1f9a : a97f            >            lda #$7f     ;precharge accu
1f9c : 28              >            plp
                        
1f9d : c97f                     cmp #$7f
                                tst_a $7f,fzc
1f9f : 08              >            php         ;save flags
1fa0 : 08              >            php
1fa1 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fa3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fa5 : 68              >            pla         ;load status
                       >            cmp_flag fzc
1fa6 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1faa : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fab : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fad : 48              >            pha         ;use stack to load status
1fae : a97e            >            lda #$7e     ;precharge accu
1fb0 : 28              >            plp
                        
1fb1 : c97f                     cmp #$7f
                                tst_a $7e,fn
1fb3 : 08              >            php         ;save flags
1fb4 : 08              >            php
1fb5 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb9 : 68              >            pla         ;load status
                       >            cmp_flag fn
1fba : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbe : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fc1 : 48              >            pha         ;use stack to load status
1fc2 : a980            >            lda #$80     ;precharge accu
1fc4 : 28              >            plp
                        
1fc5 : c97f                     cmp #$7f
                                tst_a $80,~fnz
1fc7 : 08              >            php         ;save flags
1fc8 : 08              >            php
1fc9 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fcd : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
1fce : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd2 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fd3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fd5 : 48              >            pha         ;use stack to load status
1fd6 : a97f            >            lda #$7f     ;precharge accu
1fd8 : 28              >            plp
                        
1fd9 : c97f                     cmp #$7f
                                tst_a $7f,~fn
1fdb : 08              >            php         ;save flags
1fdc : 08              >            php
1fdd : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe1 : 68              >            pla         ;load status
                       >            cmp_flag ~fn
1fe2 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fe4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe6 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1fe7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fe9 : 48              >            pha         ;use stack to load status
1fea : a97e            >            lda #$7e     ;precharge accu
1fec : 28              >            plp
                        
1fed : c97f                     cmp #$7f
                                tst_a $7e,~fzc
1fef : 08              >            php         ;save flags
1ff0 : 08              >            php
1ff1 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1ff3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ff5 : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
1ff6 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ff8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffa : 28              >            plp         ;restore status
                        
                        
1ffb : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
1ffd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fff : 48              >            pha         ;use stack to load status
2000 : a980            >            lda #$80     ;precharge accu
2002 : 28              >            plp
                        
2003 : d513                     cmp zp1,x
                                tst_a $80,fc
2005 : 08              >            php         ;save flags
2006 : 08              >            php
2007 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2009 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
200b : 68              >            pla         ;load status
                       >            cmp_flag fc
200c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
200e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2010 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2011 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2013 : 48              >            pha         ;use stack to load status
2014 : a97f            >            lda #$7f     ;precharge accu
2016 : 28              >            plp
                        
2017 : d513                     cmp zp1,x
                                tst_a $7f,fzc
2019 : 08              >            php         ;save flags
201a : 08              >            php
201b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
201d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
201f : 68              >            pla         ;load status
                       >            cmp_flag fzc
2020 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2022 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2024 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2025 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2027 : 48              >            pha         ;use stack to load status
2028 : a97e            >            lda #$7e     ;precharge accu
202a : 28              >            plp
                        
202b : d513                     cmp zp1,x
                                tst_a $7e,fn
202d : 08              >            php         ;save flags
202e : 08              >            php
202f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2031 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2033 : 68              >            pla         ;load status
                       >            cmp_flag fn
2034 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2036 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2038 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2039 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
203b : 48              >            pha         ;use stack to load status
203c : a980            >            lda #$80     ;precharge accu
203e : 28              >            plp
                        
203f : d513                     cmp zp1,x
                                tst_a $80,~fnz
2041 : 08              >            php         ;save flags
2042 : 08              >            php
2043 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2045 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2047 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
2048 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
204a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204c : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
204d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
204f : 48              >            pha         ;use stack to load status
2050 : a97f            >            lda #$7f     ;precharge accu
2052 : 28              >            plp
                        
2053 : d513                     cmp zp1,x
                                tst_a $7f,~fn
2055 : 08              >            php         ;save flags
2056 : 08              >            php
2057 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2059 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
205b : 68              >            pla         ;load status
                       >            cmp_flag ~fn
205c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
205e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2060 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2061 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2063 : 48              >            pha         ;use stack to load status
2064 : a97e            >            lda #$7e     ;precharge accu
2066 : 28              >            plp
                        
2067 : d513                     cmp zp1,x
                                tst_a $7e,~fzc
2069 : 08              >            php         ;save flags
206a : 08              >            php
206b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
206d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
206f : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
2070 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2072 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2074 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2075 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2077 : 48              >            pha         ;use stack to load status
2078 : a980            >            lda #$80     ;precharge accu
207a : 28              >            plp
                        
207b : dd0802                   cmp abs1,x
                                tst_a $80,fc
207e : 08              >            php         ;save flags
207f : 08              >            php
2080 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2082 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2084 : 68              >            pla         ;load status
                       >            cmp_flag fc
2085 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2087 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2089 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
208a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
208c : 48              >            pha         ;use stack to load status
208d : a97f            >            lda #$7f     ;precharge accu
208f : 28              >            plp
                        
2090 : dd0802                   cmp abs1,x
                                tst_a $7f,fzc
2093 : 08              >            php         ;save flags
2094 : 08              >            php
2095 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2097 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2099 : 68              >            pla         ;load status
                       >            cmp_flag fzc
209a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
209c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
209e : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
209f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20a1 : 48              >            pha         ;use stack to load status
20a2 : a97e            >            lda #$7e     ;precharge accu
20a4 : 28              >            plp
                        
20a5 : dd0802                   cmp abs1,x
                                tst_a $7e,fn
20a8 : 08              >            php         ;save flags
20a9 : 08              >            php
20aa : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ae : 68              >            pla         ;load status
                       >            cmp_flag fn
20af : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b3 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20b4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20b6 : 48              >            pha         ;use stack to load status
20b7 : a980            >            lda #$80     ;precharge accu
20b9 : 28              >            plp
                        
20ba : dd0802                   cmp abs1,x
                                tst_a $80,~fnz
20bd : 08              >            php         ;save flags
20be : 08              >            php
20bf : c980            >            cmp #$80     ;test result
                       >            trap_ne
20c1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c3 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
20c4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c8 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20cb : 48              >            pha         ;use stack to load status
20cc : a97f            >            lda #$7f     ;precharge accu
20ce : 28              >            plp
                        
20cf : dd0802                   cmp abs1,x
                                tst_a $7f,~fn
20d2 : 08              >            php         ;save flags
20d3 : 08              >            php
20d4 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d8 : 68              >            pla         ;load status
                       >            cmp_flag ~fn
20d9 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20dd : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20de : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20e0 : 48              >            pha         ;use stack to load status
20e1 : a97e            >            lda #$7e     ;precharge accu
20e3 : 28              >            plp
                        
20e4 : dd0802                   cmp abs1,x
                                tst_a $7e,~fzc
20e7 : 08              >            php         ;save flags
20e8 : 08              >            php
20e9 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ed : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
20ee : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f2 : 28              >            plp         ;restore status
                        
                        
20f3 : a004                     ldy #4          ;with indexing by Y
20f5 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
20f7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20f9 : 48              >            pha         ;use stack to load status
20fa : a980            >            lda #$80     ;precharge accu
20fc : 28              >            plp
                        
20fd : d90802                   cmp abs1,y
                                tst_a $80,fc
2100 : 08              >            php         ;save flags
2101 : 08              >            php
2102 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2104 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2106 : 68              >            pla         ;load status
                       >            cmp_flag fc
2107 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2109 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
210c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
210e : 48              >            pha         ;use stack to load status
210f : a97f            >            lda #$7f     ;precharge accu
2111 : 28              >            plp
                        
2112 : d90802                   cmp abs1,y
                                tst_a $7f,fzc
2115 : 08              >            php         ;save flags
2116 : 08              >            php
2117 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2119 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211b : 68              >            pla         ;load status
                       >            cmp_flag fzc
211c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
211e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2120 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2121 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2123 : 48              >            pha         ;use stack to load status
2124 : a97e            >            lda #$7e     ;precharge accu
2126 : 28              >            plp
                        
2127 : d90802                   cmp abs1,y
                                tst_a $7e,fn
212a : 08              >            php         ;save flags
212b : 08              >            php
212c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
212e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2130 : 68              >            pla         ;load status
                       >            cmp_flag fn
2131 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2133 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2135 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2136 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2138 : 48              >            pha         ;use stack to load status
2139 : a980            >            lda #$80     ;precharge accu
213b : 28              >            plp
                        
213c : d90802                   cmp abs1,y
                                tst_a $80,~fnz
213f : 08              >            php         ;save flags
2140 : 08              >            php
2141 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2143 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2145 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
2146 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2148 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
214b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
214d : 48              >            pha         ;use stack to load status
214e : a97f            >            lda #$7f     ;precharge accu
2150 : 28              >            plp
                        
2151 : d90802                   cmp abs1,y
                                tst_a $7f,~fn
2154 : 08              >            php         ;save flags
2155 : 08              >            php
2156 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2158 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215a : 68              >            pla         ;load status
                       >            cmp_flag ~fn
215b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
215d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2160 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2162 : 48              >            pha         ;use stack to load status
2163 : a97e            >            lda #$7e     ;precharge accu
2165 : 28              >            plp
                        
2166 : d90802                   cmp abs1,y
                                tst_a $7e,~fzc
2169 : 08              >            php         ;save flags
216a : 08              >            php
216b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
216d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
216f : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
2170 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2172 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2174 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2175 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2177 : 48              >            pha         ;use stack to load status
2178 : a980            >            lda #$80     ;precharge accu
217a : 28              >            plp
                        
217b : c124                     cmp (ind1,x)
                                tst_a $80,fc
217d : 08              >            php         ;save flags
217e : 08              >            php
217f : c980            >            cmp #$80     ;test result
                       >            trap_ne
2181 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2183 : 68              >            pla         ;load status
                       >            cmp_flag fc
2184 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2186 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2188 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2189 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
218b : 48              >            pha         ;use stack to load status
218c : a97f            >            lda #$7f     ;precharge accu
218e : 28              >            plp
                        
218f : c124                     cmp (ind1,x)
                                tst_a $7f,fzc
2191 : 08              >            php         ;save flags
2192 : 08              >            php
2193 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2195 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2197 : 68              >            pla         ;load status
                       >            cmp_flag fzc
2198 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
219a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219c : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
219d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
219f : 48              >            pha         ;use stack to load status
21a0 : a97e            >            lda #$7e     ;precharge accu
21a2 : 28              >            plp
                        
21a3 : c124                     cmp (ind1,x)
                                tst_a $7e,fn
21a5 : 08              >            php         ;save flags
21a6 : 08              >            php
21a7 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ab : 68              >            pla         ;load status
                       >            cmp_flag fn
21ac : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b0 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21b1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21b3 : 48              >            pha         ;use stack to load status
21b4 : a980            >            lda #$80     ;precharge accu
21b6 : 28              >            plp
                        
21b7 : c124                     cmp (ind1,x)
                                tst_a $80,~fnz
21b9 : 08              >            php         ;save flags
21ba : 08              >            php
21bb : c980            >            cmp #$80     ;test result
                       >            trap_ne
21bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21bf : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
21c0 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c4 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21c5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21c7 : 48              >            pha         ;use stack to load status
21c8 : a97f            >            lda #$7f     ;precharge accu
21ca : 28              >            plp
                        
21cb : c124                     cmp (ind1,x)
                                tst_a $7f,~fn
21cd : 08              >            php         ;save flags
21ce : 08              >            php
21cf : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21d1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d3 : 68              >            pla         ;load status
                       >            cmp_flag ~fn
21d4 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d8 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
21d9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21db : 48              >            pha         ;use stack to load status
21dc : a97e            >            lda #$7e     ;precharge accu
21de : 28              >            plp
                        
21df : c124                     cmp (ind1,x)
                                tst_a $7e,~fzc
21e1 : 08              >            php         ;save flags
21e2 : 08              >            php
21e3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21e5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21e7 : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
21e8 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ec : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21ed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21ef : 48              >            pha         ;use stack to load status
21f0 : a980            >            lda #$80     ;precharge accu
21f2 : 28              >            plp
                        
21f3 : d124                     cmp (ind1),y
                                tst_a $80,fc
21f5 : 08              >            php         ;save flags
21f6 : 08              >            php
21f7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21fb : 68              >            pla         ;load status
                       >            cmp_flag fc
21fc : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2200 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2201 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2203 : 48              >            pha         ;use stack to load status
2204 : a97f            >            lda #$7f     ;precharge accu
2206 : 28              >            plp
                        
2207 : d124                     cmp (ind1),y
                                tst_a $7f,fzc
2209 : 08              >            php         ;save flags
220a : 08              >            php
220b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
220d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
220f : 68              >            pla         ;load status
                       >            cmp_flag fzc
2210 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2212 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2214 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2215 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2217 : 48              >            pha         ;use stack to load status
2218 : a97e            >            lda #$7e     ;precharge accu
221a : 28              >            plp
                        
221b : d124                     cmp (ind1),y
                                tst_a $7e,fn
221d : 08              >            php         ;save flags
221e : 08              >            php
221f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2221 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2223 : 68              >            pla         ;load status
                       >            cmp_flag fn
2224 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2226 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2228 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2229 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
222b : 48              >            pha         ;use stack to load status
222c : a980            >            lda #$80     ;precharge accu
222e : 28              >            plp
                        
222f : d124                     cmp (ind1),y
                                tst_a $80,~fnz
2231 : 08              >            php         ;save flags
2232 : 08              >            php
2233 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2235 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2237 : 68              >            pla         ;load status
                       >            cmp_flag ~fnz
2238 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
223a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223c : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
223d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
223f : 48              >            pha         ;use stack to load status
2240 : a97f            >            lda #$7f     ;precharge accu
2242 : 28              >            plp
                        
2243 : d124                     cmp (ind1),y
                                tst_a $7f,~fn
2245 : 08              >            php         ;save flags
2246 : 08              >            php
2247 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2249 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
224b : 68              >            pla         ;load status
                       >            cmp_flag ~fn
224c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
224e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2250 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2251 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2253 : 48              >            pha         ;use stack to load status
2254 : a97e            >            lda #$7e     ;precharge accu
2256 : 28              >            plp
                        
2257 : d124                     cmp (ind1),y
                                tst_a $7e,~fzc
2259 : 08              >            php         ;save flags
225a : 08              >            php
225b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
225d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
225f : 68              >            pla         ;load status
                       >            cmp_flag ~fzc
2260 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2262 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2264 : 28              >            plp         ;restore status
                        
                                next_test
2265 : ad0002          >            lda test_case   ;previous test
2268 : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
226a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
226c : a91d            >            lda #test_num   ;*** next tests' number
226e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
2271 : a203                     ldx #3
2273 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
2273 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2275 : 48              >            pha         ;use stack to load status
2276 : b513            >            lda zp1,x    ;precharge accu
2278 : 28              >            plp
                        
2279 : 0a                       asl a
                                tst_ax rASL,fASL,0
227a : 08              >            php         ;save flags
227b : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
227e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2280 : 68              >            pla         ;load status
                       >            eor_flag 0
2281 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2283 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
2286 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2288 : ca                       dex
2289 : 10e8                     bpl tasl
228b : a203                     ldx #3
228d :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
228d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
228f : 48              >            pha         ;use stack to load status
2290 : b513            >            lda zp1,x    ;precharge accu
2292 : 28              >            plp
                        
2293 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
2294 : 08              >            php         ;save flags
2295 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
2298 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
229a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
229b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
229d : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22a2 : ca                       dex
22a3 : 10e8                     bpl tasl1
                        
22a5 : a203                     ldx #3
22a7 :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
22a7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22a9 : 48              >            pha         ;use stack to load status
22aa : b513            >            lda zp1,x    ;precharge accu
22ac : 28              >            plp
                        
22ad : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
22ae : 08              >            php         ;save flags
22af : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
22b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22b4 : 68              >            pla         ;load status
                       >            eor_flag 0
22b5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22b7 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22bc : ca                       dex
22bd : 10e8                     bpl tlsr
22bf : a203                     ldx #3
22c1 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
22c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22c3 : 48              >            pha         ;use stack to load status
22c4 : b513            >            lda zp1,x    ;precharge accu
22c6 : 28              >            plp
                        
22c7 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
22c8 : 08              >            php         ;save flags
22c9 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
22cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ce : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22cf : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22d1 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22d6 : ca                       dex
22d7 : 10e8                     bpl tlsr1
                        
22d9 : a203                     ldx #3
22db :                  trol
                                set_ax zp1,0
                       >            load_flag 0
22db : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22dd : 48              >            pha         ;use stack to load status
22de : b513            >            lda zp1,x    ;precharge accu
22e0 : 28              >            plp
                        
22e1 : 2a                       rol a
                                tst_ax rROL,fROL,0
22e2 : 08              >            php         ;save flags
22e3 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
22e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e8 : 68              >            pla         ;load status
                       >            eor_flag 0
22e9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22eb : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
22ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22f0 : ca                       dex
22f1 : 10e8                     bpl trol
22f3 : a203                     ldx #3
22f5 :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
22f5 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
22f7 : 48              >            pha         ;use stack to load status
22f8 : b513            >            lda zp1,x    ;precharge accu
22fa : 28              >            plp
                        
22fb : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
22fc : 08              >            php         ;save flags
22fd : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2300 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2302 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2303 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2305 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2308 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
230a : ca                       dex
230b : 10e8                     bpl trol1
                        
230d : a203                     ldx #3
230f :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
230f : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2311 : 48              >            pha         ;use stack to load status
2312 : b513            >            lda zp1,x    ;precharge accu
2314 : 28              >            plp
                        
2315 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2316 : 08              >            php         ;save flags
2317 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
231a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
231c : 68              >            pla         ;load status
                       >            eor_flag 0
231d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
231f : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2322 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2324 : ca                       dex
2325 : 10e8                     bpl trolc
2327 : a203                     ldx #3
2329 :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2329 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
232b : 48              >            pha         ;use stack to load status
232c : b513            >            lda zp1,x    ;precharge accu
232e : 28              >            plp
                        
232f : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
2330 : 08              >            php         ;save flags
2331 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2334 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2336 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2337 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2339 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
233c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
233e : ca                       dex
233f : 10e8                     bpl trolc1
                        
2341 : a203                     ldx #3
2343 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
2343 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2345 : 48              >            pha         ;use stack to load status
2346 : b513            >            lda zp1,x    ;precharge accu
2348 : 28              >            plp
                        
2349 : 6a                       ror a
                                tst_ax rROR,fROR,0
234a : 08              >            php         ;save flags
234b : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
234e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2350 : 68              >            pla         ;load status
                       >            eor_flag 0
2351 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2353 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2356 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2358 : ca                       dex
2359 : 10e8                     bpl tror
235b : a203                     ldx #3
235d :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
235d : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
235f : 48              >            pha         ;use stack to load status
2360 : b513            >            lda zp1,x    ;precharge accu
2362 : 28              >            plp
                        
2363 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
2364 : 08              >            php         ;save flags
2365 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
2368 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
236a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
236b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
236d : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2370 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2372 : ca                       dex
2373 : 10e8                     bpl tror1
                        
2375 : a203                     ldx #3
2377 :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
2377 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2379 : 48              >            pha         ;use stack to load status
237a : b513            >            lda zp1,x    ;precharge accu
237c : 28              >            plp
                        
237d : 6a                       ror a
                                tst_ax rRORc,fRORc,0
237e : 08              >            php         ;save flags
237f : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2382 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2384 : 68              >            pla         ;load status
                       >            eor_flag 0
2385 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2387 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
238a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
238c : ca                       dex
238d : 10e8                     bpl trorc
238f : a203                     ldx #3
2391 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2391 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2393 : 48              >            pha         ;use stack to load status
2394 : b513            >            lda zp1,x    ;precharge accu
2396 : 28              >            plp
                        
2397 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
2398 : 08              >            php         ;save flags
2399 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
239c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
239e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
239f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23a1 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23a6 : ca                       dex
23a7 : 10e8                     bpl trorc1
                                next_test
23a9 : ad0002          >            lda test_case   ;previous test
23ac : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
23ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
23b0 : a91e            >            lda #test_num   ;*** next tests' number
23b2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
23b5 : a203                     ldx #3
23b7 :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
23b7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23b9 : 48              >            pha         ;use stack to load status
23ba : b513            >            lda zp1,x    ;load to zeropage
23bc : 850c            >            sta zpt
23be : 28              >            plp
                        
23bf : 060c                     asl zpt
                                tst_z rASL,fASL,0
23c1 : 08              >            php         ;save flags
23c2 : a50c            >            lda zpt
23c4 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
23c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23c9 : 68              >            pla         ;load status
                       >            eor_flag 0
23ca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23cc : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
23cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23d1 : ca                       dex
23d2 : 10e3                     bpl tasl2
23d4 : a203                     ldx #3
23d6 :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
23d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23d8 : 48              >            pha         ;use stack to load status
23d9 : b513            >            lda zp1,x    ;load to zeropage
23db : 850c            >            sta zpt
23dd : 28              >            plp
                        
23de : 060c                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
23e0 : 08              >            php         ;save flags
23e1 : a50c            >            lda zpt
23e3 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
23e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23e8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23e9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23eb : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
23ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23f0 : ca                       dex
23f1 : 10e3                     bpl tasl3
                        
23f3 : a203                     ldx #3
23f5 :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
23f5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23f7 : 48              >            pha         ;use stack to load status
23f8 : b513            >            lda zp1,x    ;load to zeropage
23fa : 850c            >            sta zpt
23fc : 28              >            plp
                        
23fd : 460c                     lsr zpt
                                tst_z rLSR,fLSR,0
23ff : 08              >            php         ;save flags
2400 : a50c            >            lda zpt
2402 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2405 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2407 : 68              >            pla         ;load status
                       >            eor_flag 0
2408 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
240a : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
240d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
240f : ca                       dex
2410 : 10e3                     bpl tlsr2
2412 : a203                     ldx #3
2414 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
2414 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2416 : 48              >            pha         ;use stack to load status
2417 : b513            >            lda zp1,x    ;load to zeropage
2419 : 850c            >            sta zpt
241b : 28              >            plp
                        
241c : 460c                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
241e : 08              >            php         ;save flags
241f : a50c            >            lda zpt
2421 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2424 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2426 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2427 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2429 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
242c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
242e : ca                       dex
242f : 10e3                     bpl tlsr3
                        
2431 : a203                     ldx #3
2433 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
2433 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2435 : 48              >            pha         ;use stack to load status
2436 : b513            >            lda zp1,x    ;load to zeropage
2438 : 850c            >            sta zpt
243a : 28              >            plp
                        
243b : 260c                     rol zpt
                                tst_z rROL,fROL,0
243d : 08              >            php         ;save flags
243e : a50c            >            lda zpt
2440 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2443 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2445 : 68              >            pla         ;load status
                       >            eor_flag 0
2446 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2448 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
244b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
244d : ca                       dex
244e : 10e3                     bpl trol2
2450 : a203                     ldx #3
2452 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2452 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2454 : 48              >            pha         ;use stack to load status
2455 : b513            >            lda zp1,x    ;load to zeropage
2457 : 850c            >            sta zpt
2459 : 28              >            plp
                        
245a : 260c                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
245c : 08              >            php         ;save flags
245d : a50c            >            lda zpt
245f : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2462 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2464 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2465 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2467 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
246a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
246c : ca                       dex
246d : 10e3                     bpl trol3
                        
246f : a203                     ldx #3
2471 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
2471 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2473 : 48              >            pha         ;use stack to load status
2474 : b513            >            lda zp1,x    ;load to zeropage
2476 : 850c            >            sta zpt
2478 : 28              >            plp
                        
2479 : 260c                     rol zpt
                                tst_z rROLc,fROLc,0
247b : 08              >            php         ;save flags
247c : a50c            >            lda zpt
247e : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2481 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2483 : 68              >            pla         ;load status
                       >            eor_flag 0
2484 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2486 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2489 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
248b : ca                       dex
248c : 10e3                     bpl trolc2
248e : a203                     ldx #3
2490 :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
2490 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2492 : 48              >            pha         ;use stack to load status
2493 : b513            >            lda zp1,x    ;load to zeropage
2495 : 850c            >            sta zpt
2497 : 28              >            plp
                        
2498 : 260c                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
249a : 08              >            php         ;save flags
249b : a50c            >            lda zpt
249d : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
24a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24a2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24a3 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24a5 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24aa : ca                       dex
24ab : 10e3                     bpl trolc3
                        
24ad : a203                     ldx #3
24af :                  tror2
                                set_z zp1,0
                       >            load_flag 0
24af : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24b1 : 48              >            pha         ;use stack to load status
24b2 : b513            >            lda zp1,x    ;load to zeropage
24b4 : 850c            >            sta zpt
24b6 : 28              >            plp
                        
24b7 : 660c                     ror zpt
                                tst_z rROR,fROR,0
24b9 : 08              >            php         ;save flags
24ba : a50c            >            lda zpt
24bc : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
24bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24c1 : 68              >            pla         ;load status
                       >            eor_flag 0
24c2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24c4 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
24c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24c9 : ca                       dex
24ca : 10e3                     bpl tror2
24cc : a203                     ldx #3
24ce :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24ce : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24d0 : 48              >            pha         ;use stack to load status
24d1 : b513            >            lda zp1,x    ;load to zeropage
24d3 : 850c            >            sta zpt
24d5 : 28              >            plp
                        
24d6 : 660c                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
24d8 : 08              >            php         ;save flags
24d9 : a50c            >            lda zpt
24db : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
24de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24e0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24e1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24e3 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
24e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24e8 : ca                       dex
24e9 : 10e3                     bpl tror3
                        
24eb : a203                     ldx #3
24ed :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
24ed : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
24ef : 48              >            pha         ;use stack to load status
24f0 : b513            >            lda zp1,x    ;load to zeropage
24f2 : 850c            >            sta zpt
24f4 : 28              >            plp
                        
24f5 : 660c                     ror zpt
                                tst_z rRORc,fRORc,0
24f7 : 08              >            php         ;save flags
24f8 : a50c            >            lda zpt
24fa : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
24fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ff : 68              >            pla         ;load status
                       >            eor_flag 0
2500 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2502 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2505 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2507 : ca                       dex
2508 : 10e3                     bpl trorc2
250a : a203                     ldx #3
250c :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
250c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
250e : 48              >            pha         ;use stack to load status
250f : b513            >            lda zp1,x    ;load to zeropage
2511 : 850c            >            sta zpt
2513 : 28              >            plp
                        
2514 : 660c                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
2516 : 08              >            php         ;save flags
2517 : a50c            >            lda zpt
2519 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
251c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
251e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
251f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2521 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2524 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2526 : ca                       dex
2527 : 10e3                     bpl trorc3
                                next_test
2529 : ad0002          >            lda test_case   ;previous test
252c : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
252e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
2530 : a91f            >            lda #test_num   ;*** next tests' number
2532 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
2535 : a203                     ldx #3
2537 :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
2537 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2539 : 48              >            pha         ;use stack to load status
253a : b513            >            lda zp1,x    ;load to memory
253c : 8d0302          >            sta abst
253f : 28              >            plp
                        
2540 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2543 : 08              >            php         ;save flags
2544 : ad0302          >            lda abst
2547 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
254a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
254c : 68              >            pla         ;load status
                       >            eor_flag 0
254d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
254f : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2552 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2554 : ca                       dex
2555 : 10e0                     bpl tasl4
2557 : a203                     ldx #3
2559 :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
2559 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
255b : 48              >            pha         ;use stack to load status
255c : b513            >            lda zp1,x    ;load to memory
255e : 8d0302          >            sta abst
2561 : 28              >            plp
                        
2562 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
2565 : 08              >            php         ;save flags
2566 : ad0302          >            lda abst
2569 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
256c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
256e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
256f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2571 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2574 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2576 : ca                       dex
2577 : 10e0                     bpl tasl5
                        
2579 : a203                     ldx #3
257b :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
257b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
257d : 48              >            pha         ;use stack to load status
257e : b513            >            lda zp1,x    ;load to memory
2580 : 8d0302          >            sta abst
2583 : 28              >            plp
                        
2584 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
2587 : 08              >            php         ;save flags
2588 : ad0302          >            lda abst
258b : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
258e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2590 : 68              >            pla         ;load status
                       >            eor_flag 0
2591 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2593 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2596 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2598 : ca                       dex
2599 : 10e0                     bpl tlsr4
259b : a203                     ldx #3
259d :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
259d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
259f : 48              >            pha         ;use stack to load status
25a0 : b513            >            lda zp1,x    ;load to memory
25a2 : 8d0302          >            sta abst
25a5 : 28              >            plp
                        
25a6 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
25a9 : 08              >            php         ;save flags
25aa : ad0302          >            lda abst
25ad : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
25b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25b2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25b3 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25b5 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25ba : ca                       dex
25bb : 10e0                     bpl tlsr5
                        
25bd : a203                     ldx #3
25bf :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
25bf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25c1 : 48              >            pha         ;use stack to load status
25c2 : b513            >            lda zp1,x    ;load to memory
25c4 : 8d0302          >            sta abst
25c7 : 28              >            plp
                        
25c8 : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
25cb : 08              >            php         ;save flags
25cc : ad0302          >            lda abst
25cf : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
25d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25d4 : 68              >            pla         ;load status
                       >            eor_flag 0
25d5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25d7 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
25da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25dc : ca                       dex
25dd : 10e0                     bpl trol4
25df : a203                     ldx #3
25e1 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
25e1 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
25e3 : 48              >            pha         ;use stack to load status
25e4 : b513            >            lda zp1,x    ;load to memory
25e6 : 8d0302          >            sta abst
25e9 : 28              >            plp
                        
25ea : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
25ed : 08              >            php         ;save flags
25ee : ad0302          >            lda abst
25f1 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
25f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25f6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25f7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25f9 : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
25fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25fe : ca                       dex
25ff : 10e0                     bpl trol5
                        
2601 : a203                     ldx #3
2603 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
2603 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2605 : 48              >            pha         ;use stack to load status
2606 : b513            >            lda zp1,x    ;load to memory
2608 : 8d0302          >            sta abst
260b : 28              >            plp
                        
260c : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
260f : 08              >            php         ;save flags
2610 : ad0302          >            lda abst
2613 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2616 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2618 : 68              >            pla         ;load status
                       >            eor_flag 0
2619 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
261b : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
261e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2620 : ca                       dex
2621 : 10e0                     bpl trolc4
2623 : a203                     ldx #3
2625 :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2625 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2627 : 48              >            pha         ;use stack to load status
2628 : b513            >            lda zp1,x    ;load to memory
262a : 8d0302          >            sta abst
262d : 28              >            plp
                        
262e : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2631 : 08              >            php         ;save flags
2632 : ad0302          >            lda abst
2635 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
2638 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
263a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
263b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
263d : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2640 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2642 : ca                       dex
2643 : 10e0                     bpl trolc5
                        
2645 : a203                     ldx #3
2647 :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
2647 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2649 : 48              >            pha         ;use stack to load status
264a : b513            >            lda zp1,x    ;load to memory
264c : 8d0302          >            sta abst
264f : 28              >            plp
                        
2650 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2653 : 08              >            php         ;save flags
2654 : ad0302          >            lda abst
2657 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
265a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
265c : 68              >            pla         ;load status
                       >            eor_flag 0
265d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
265f : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2662 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2664 : ca                       dex
2665 : 10e0                     bpl tror4
2667 : a203                     ldx #3
2669 :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2669 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
266b : 48              >            pha         ;use stack to load status
266c : b513            >            lda zp1,x    ;load to memory
266e : 8d0302          >            sta abst
2671 : 28              >            plp
                        
2672 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
2675 : 08              >            php         ;save flags
2676 : ad0302          >            lda abst
2679 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
267c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
267e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
267f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2681 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2684 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2686 : ca                       dex
2687 : 10e0                     bpl tror5
                        
2689 : a203                     ldx #3
268b :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
268b : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
268d : 48              >            pha         ;use stack to load status
268e : b513            >            lda zp1,x    ;load to memory
2690 : 8d0302          >            sta abst
2693 : 28              >            plp
                        
2694 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
2697 : 08              >            php         ;save flags
2698 : ad0302          >            lda abst
269b : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
269e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26a0 : 68              >            pla         ;load status
                       >            eor_flag 0
26a1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26a3 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26a8 : ca                       dex
26a9 : 10e0                     bpl trorc4
26ab : a203                     ldx #3
26ad :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
26ad : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26af : 48              >            pha         ;use stack to load status
26b0 : b513            >            lda zp1,x    ;load to memory
26b2 : 8d0302          >            sta abst
26b5 : 28              >            plp
                        
26b6 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
26b9 : 08              >            php         ;save flags
26ba : ad0302          >            lda abst
26bd : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26c2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26c3 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26c5 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26ca : ca                       dex
26cb : 10e0                     bpl trorc5
                                next_test
26cd : ad0002          >            lda test_case   ;previous test
26d0 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
26d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
26d4 : a920            >            lda #test_num   ;*** next tests' number
26d6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
26d9 : a203                     ldx #3
26db :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
26db : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26dd : 48              >            pha         ;use stack to load status
26de : b513            >            lda zp1,x    ;load to indexed zeropage
26e0 : 950c            >            sta zpt,x
26e2 : 28              >            plp
                        
26e3 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,0
26e5 : 08              >            php         ;save flags
26e6 : b50c            >            lda zpt,x
26e8 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
26eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26ed : 68              >            pla         ;load status
                       >            eor_flag 0
26ee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26f0 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
26f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26f5 : ca                       dex
26f6 : 10e3                     bpl tasl6
26f8 : a203                     ldx #3
26fa :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
26fa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26fc : 48              >            pha         ;use stack to load status
26fd : b513            >            lda zp1,x    ;load to indexed zeropage
26ff : 950c            >            sta zpt,x
2701 : 28              >            plp
                        
2702 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2704 : 08              >            php         ;save flags
2705 : b50c            >            lda zpt,x
2707 : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
270a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
270c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
270d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
270f : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2712 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2714 : ca                       dex
2715 : 10e3                     bpl tasl7
                        
2717 : a203                     ldx #3
2719 :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
2719 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
271b : 48              >            pha         ;use stack to load status
271c : b513            >            lda zp1,x    ;load to indexed zeropage
271e : 950c            >            sta zpt,x
2720 : 28              >            plp
                        
2721 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2723 : 08              >            php         ;save flags
2724 : b50c            >            lda zpt,x
2726 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2729 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
272b : 68              >            pla         ;load status
                       >            eor_flag 0
272c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
272e : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2731 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2733 : ca                       dex
2734 : 10e3                     bpl tlsr6
2736 : a203                     ldx #3
2738 :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
2738 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
273a : 48              >            pha         ;use stack to load status
273b : b513            >            lda zp1,x    ;load to indexed zeropage
273d : 950c            >            sta zpt,x
273f : 28              >            plp
                        
2740 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2742 : 08              >            php         ;save flags
2743 : b50c            >            lda zpt,x
2745 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
2748 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
274a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
274b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
274d : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2750 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2752 : ca                       dex
2753 : 10e3                     bpl tlsr7
                        
2755 : a203                     ldx #3
2757 :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
2757 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2759 : 48              >            pha         ;use stack to load status
275a : b513            >            lda zp1,x    ;load to indexed zeropage
275c : 950c            >            sta zpt,x
275e : 28              >            plp
                        
275f : 360c                     rol zpt,x
                                tst_zx rROL,fROL,0
2761 : 08              >            php         ;save flags
2762 : b50c            >            lda zpt,x
2764 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2767 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2769 : 68              >            pla         ;load status
                       >            eor_flag 0
276a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
276c : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
276f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2771 : ca                       dex
2772 : 10e3                     bpl trol6
2774 : a203                     ldx #3
2776 :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2776 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2778 : 48              >            pha         ;use stack to load status
2779 : b513            >            lda zp1,x    ;load to indexed zeropage
277b : 950c            >            sta zpt,x
277d : 28              >            plp
                        
277e : 360c                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
2780 : 08              >            php         ;save flags
2781 : b50c            >            lda zpt,x
2783 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2786 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2788 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2789 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
278b : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
278e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2790 : ca                       dex
2791 : 10e3                     bpl trol7
                        
2793 : a203                     ldx #3
2795 :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
2795 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2797 : 48              >            pha         ;use stack to load status
2798 : b513            >            lda zp1,x    ;load to indexed zeropage
279a : 950c            >            sta zpt,x
279c : 28              >            plp
                        
279d : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,0
279f : 08              >            php         ;save flags
27a0 : b50c            >            lda zpt,x
27a2 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
27a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27a7 : 68              >            pla         ;load status
                       >            eor_flag 0
27a8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27aa : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27af : ca                       dex
27b0 : 10e3                     bpl trolc6
27b2 : a203                     ldx #3
27b4 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
27b4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27b6 : 48              >            pha         ;use stack to load status
27b7 : b513            >            lda zp1,x    ;load to indexed zeropage
27b9 : 950c            >            sta zpt,x
27bb : 28              >            plp
                        
27bc : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
27be : 08              >            php         ;save flags
27bf : b50c            >            lda zpt,x
27c1 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
27c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27c6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27c7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27c9 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27ce : ca                       dex
27cf : 10e3                     bpl trolc7
                        
27d1 : a203                     ldx #3
27d3 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
27d3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27d5 : 48              >            pha         ;use stack to load status
27d6 : b513            >            lda zp1,x    ;load to indexed zeropage
27d8 : 950c            >            sta zpt,x
27da : 28              >            plp
                        
27db : 760c                     ror zpt,x
                                tst_zx rROR,fROR,0
27dd : 08              >            php         ;save flags
27de : b50c            >            lda zpt,x
27e0 : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
27e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27e5 : 68              >            pla         ;load status
                       >            eor_flag 0
27e6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27e8 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
27eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27ed : ca                       dex
27ee : 10e3                     bpl tror6
27f0 : a203                     ldx #3
27f2 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27f2 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27f4 : 48              >            pha         ;use stack to load status
27f5 : b513            >            lda zp1,x    ;load to indexed zeropage
27f7 : 950c            >            sta zpt,x
27f9 : 28              >            plp
                        
27fa : 760c                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
27fc : 08              >            php         ;save flags
27fd : b50c            >            lda zpt,x
27ff : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
2802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2804 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2805 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2807 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
280a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
280c : ca                       dex
280d : 10e3                     bpl tror7
                        
280f : a203                     ldx #3
2811 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
2811 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2813 : 48              >            pha         ;use stack to load status
2814 : b513            >            lda zp1,x    ;load to indexed zeropage
2816 : 950c            >            sta zpt,x
2818 : 28              >            plp
                        
2819 : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,0
281b : 08              >            php         ;save flags
281c : b50c            >            lda zpt,x
281e : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2821 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2823 : 68              >            pla         ;load status
                       >            eor_flag 0
2824 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2826 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2829 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
282b : ca                       dex
282c : 10e3                     bpl trorc6
282e : a203                     ldx #3
2830 :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2830 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2832 : 48              >            pha         ;use stack to load status
2833 : b513            >            lda zp1,x    ;load to indexed zeropage
2835 : 950c            >            sta zpt,x
2837 : 28              >            plp
                        
2838 : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
283a : 08              >            php         ;save flags
283b : b50c            >            lda zpt,x
283d : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2840 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2842 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2843 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2845 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2848 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
284a : ca                       dex
284b : 10e3                     bpl trorc7
                                next_test
284d : ad0002          >            lda test_case   ;previous test
2850 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2852 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2854 : a921            >            lda #test_num   ;*** next tests' number
2856 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
2859 : a203                     ldx #3
285b :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
285b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
285d : 48              >            pha         ;use stack to load status
285e : b513            >            lda zp1,x    ;load to indexed memory
2860 : 9d0302          >            sta abst,x
2863 : 28              >            plp
                        
2864 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
2867 : 08              >            php         ;save flags
2868 : bd0302          >            lda abst,x
286b : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
286e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2870 : 68              >            pla         ;load status
                       >            eor_flag 0
2871 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2873 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2876 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2878 : ca                       dex
2879 : 10e0                     bpl tasl8
287b : a203                     ldx #3
287d :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
287d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
287f : 48              >            pha         ;use stack to load status
2880 : b513            >            lda zp1,x    ;load to indexed memory
2882 : 9d0302          >            sta abst,x
2885 : 28              >            plp
                        
2886 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
2889 : 08              >            php         ;save flags
288a : bd0302          >            lda abst,x
288d : dd1102          >            cmp rASL,x    ;test result
                       >            trap_ne
2890 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2892 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2893 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2895 : dd2102          >            cmp fASL,x    ;test flags
                       >            trap_ne
2898 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
289a : ca                       dex
289b : 10e0                     bpl tasl9
                        
289d : a203                     ldx #3
289f :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
289f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28a1 : 48              >            pha         ;use stack to load status
28a2 : b513            >            lda zp1,x    ;load to indexed memory
28a4 : 9d0302          >            sta abst,x
28a7 : 28              >            plp
                        
28a8 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
28ab : 08              >            php         ;save flags
28ac : bd0302          >            lda abst,x
28af : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
28b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28b4 : 68              >            pla         ;load status
                       >            eor_flag 0
28b5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28b7 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28bc : ca                       dex
28bd : 10e0                     bpl tlsr8
28bf : a203                     ldx #3
28c1 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
28c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28c3 : 48              >            pha         ;use stack to load status
28c4 : b513            >            lda zp1,x    ;load to indexed memory
28c6 : 9d0302          >            sta abst,x
28c9 : 28              >            plp
                        
28ca : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
28cd : 08              >            php         ;save flags
28ce : bd0302          >            lda abst,x
28d1 : dd1902          >            cmp rLSR,x    ;test result
                       >            trap_ne
28d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28d6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28d7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28d9 : dd2902          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28de : ca                       dex
28df : 10e0                     bpl tlsr9
                        
28e1 : a203                     ldx #3
28e3 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
28e3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28e5 : 48              >            pha         ;use stack to load status
28e6 : b513            >            lda zp1,x    ;load to indexed memory
28e8 : 9d0302          >            sta abst,x
28eb : 28              >            plp
                        
28ec : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
28ef : 08              >            php         ;save flags
28f0 : bd0302          >            lda abst,x
28f3 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
28f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28f8 : 68              >            pla         ;load status
                       >            eor_flag 0
28f9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28fb : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
28fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2900 : ca                       dex
2901 : 10e0                     bpl trol8
2903 : a203                     ldx #3
2905 :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2905 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2907 : 48              >            pha         ;use stack to load status
2908 : b513            >            lda zp1,x    ;load to indexed memory
290a : 9d0302          >            sta abst,x
290d : 28              >            plp
                        
290e : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2911 : 08              >            php         ;save flags
2912 : bd0302          >            lda abst,x
2915 : dd1102          >            cmp rROL,x    ;test result
                       >            trap_ne
2918 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
291a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
291b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
291d : dd2102          >            cmp fROL,x    ;test flags
                       >            trap_ne
2920 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2922 : ca                       dex
2923 : 10e0                     bpl trol9
                        
2925 : a203                     ldx #3
2927 :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
2927 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2929 : 48              >            pha         ;use stack to load status
292a : b513            >            lda zp1,x    ;load to indexed memory
292c : 9d0302          >            sta abst,x
292f : 28              >            plp
                        
2930 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2933 : 08              >            php         ;save flags
2934 : bd0302          >            lda abst,x
2937 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
293a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
293c : 68              >            pla         ;load status
                       >            eor_flag 0
293d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
293f : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2942 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2944 : ca                       dex
2945 : 10e0                     bpl trolc8
2947 : a203                     ldx #3
2949 :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2949 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
294b : 48              >            pha         ;use stack to load status
294c : b513            >            lda zp1,x    ;load to indexed memory
294e : 9d0302          >            sta abst,x
2951 : 28              >            plp
                        
2952 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2955 : 08              >            php         ;save flags
2956 : bd0302          >            lda abst,x
2959 : dd1502          >            cmp rROLc,x    ;test result
                       >            trap_ne
295c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
295e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
295f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2961 : dd2502          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2964 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2966 : ca                       dex
2967 : 10e0                     bpl trolc9
                        
2969 : a203                     ldx #3
296b :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
296b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
296d : 48              >            pha         ;use stack to load status
296e : b513            >            lda zp1,x    ;load to indexed memory
2970 : 9d0302          >            sta abst,x
2973 : 28              >            plp
                        
2974 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
2977 : 08              >            php         ;save flags
2978 : bd0302          >            lda abst,x
297b : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
297e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2980 : 68              >            pla         ;load status
                       >            eor_flag 0
2981 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2983 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
2986 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2988 : ca                       dex
2989 : 10e0                     bpl tror8
298b : a203                     ldx #3
298d :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
298d : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
298f : 48              >            pha         ;use stack to load status
2990 : b513            >            lda zp1,x    ;load to indexed memory
2992 : 9d0302          >            sta abst,x
2995 : 28              >            plp
                        
2996 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
2999 : 08              >            php         ;save flags
299a : bd0302          >            lda abst,x
299d : dd1902          >            cmp rROR,x    ;test result
                       >            trap_ne
29a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29a2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29a3 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29a5 : dd2902          >            cmp fROR,x    ;test flags
                       >            trap_ne
29a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29aa : ca                       dex
29ab : 10e0                     bpl tror9
                        
29ad : a203                     ldx #3
29af :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
29af : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
29b1 : 48              >            pha         ;use stack to load status
29b2 : b513            >            lda zp1,x    ;load to indexed memory
29b4 : 9d0302          >            sta abst,x
29b7 : 28              >            plp
                        
29b8 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
29bb : 08              >            php         ;save flags
29bc : bd0302          >            lda abst,x
29bf : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29c4 : 68              >            pla         ;load status
                       >            eor_flag 0
29c5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29c7 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29cc : ca                       dex
29cd : 10e0                     bpl trorc8
29cf : a203                     ldx #3
29d1 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
29d1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29d3 : 48              >            pha         ;use stack to load status
29d4 : b513            >            lda zp1,x    ;load to indexed memory
29d6 : 9d0302          >            sta abst,x
29d9 : 28              >            plp
                        
29da : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
29dd : 08              >            php         ;save flags
29de : bd0302          >            lda abst,x
29e1 : dd1d02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29e6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29e7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29e9 : dd2d02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ee : ca                       dex
29ef : 10e0                     bpl trorc9
                                next_test
29f1 : ad0002          >            lda test_case   ;previous test
29f4 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
29f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
29f8 : a922            >            lda #test_num   ;*** next tests' number
29fa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
29fd : a200                     ldx #0
29ff : a97e                     lda #$7e
2a01 : 850c                     sta zpt
2a03 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a03 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a05 : 48              >            pha         ;use stack to load status
2a06 : 28              >            plp
                        
2a07 : e60c                     inc zpt
                                tst_z rINC,fINC,0
2a09 : 08              >            php         ;save flags
2a0a : a50c            >            lda zpt
2a0c : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a0f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a11 : 68              >            pla         ;load status
                       >            eor_flag 0
2a12 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a14 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a19 : e8                       inx
2a1a : e002                     cpx #2
2a1c : d004                     bne tinc1
2a1e : a9fe                     lda #$fe
2a20 : 850c                     sta zpt
2a22 : e005             tinc1   cpx #5
2a24 : d0dd                     bne tinc
2a26 : ca                       dex
2a27 : e60c                     inc zpt
2a29 :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a29 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a2b : 48              >            pha         ;use stack to load status
2a2c : 28              >            plp
                        
2a2d : c60c                     dec zpt
                                tst_z rINC,fINC,0
2a2f : 08              >            php         ;save flags
2a30 : a50c            >            lda zpt
2a32 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a37 : 68              >            pla         ;load status
                       >            eor_flag 0
2a38 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a3a : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a3f : ca                       dex
2a40 : 300a                     bmi tdec1
2a42 : e001                     cpx #1
2a44 : d0e3                     bne tdec
2a46 : a981                     lda #$81
2a48 : 850c                     sta zpt
2a4a : d0dd                     bne tdec
2a4c :                  tdec1
2a4c : a200                     ldx #0
2a4e : a97e                     lda #$7e
2a50 : 850c                     sta zpt
2a52 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2a52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a54 : 48              >            pha         ;use stack to load status
2a55 : 28              >            plp
                        
2a56 : e60c                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2a58 : 08              >            php         ;save flags
2a59 : a50c            >            lda zpt
2a5b : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a60 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a61 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a63 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a68 : e8                       inx
2a69 : e002                     cpx #2
2a6b : d004                     bne tinc11
2a6d : a9fe                     lda #$fe
2a6f : 850c                     sta zpt
2a71 : e005             tinc11  cpx #5
2a73 : d0dd                     bne tinc10
2a75 : ca                       dex
2a76 : e60c                     inc zpt
2a78 :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2a78 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a7a : 48              >            pha         ;use stack to load status
2a7b : 28              >            plp
                        
2a7c : c60c                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2a7e : 08              >            php         ;save flags
2a7f : a50c            >            lda zpt
2a81 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a86 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a87 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a89 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a8e : ca                       dex
2a8f : 300a                     bmi tdec11
2a91 : e001                     cpx #1
2a93 : d0e3                     bne tdec10
2a95 : a981                     lda #$81
2a97 : 850c                     sta zpt
2a99 : d0dd                     bne tdec10
2a9b :                  tdec11
                                next_test
2a9b : ad0002          >            lda test_case   ;previous test
2a9e : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2aa0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2aa2 : a923            >            lda #test_num   ;*** next tests' number
2aa4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2aa7 : a200                     ldx #0
2aa9 : a97e                     lda #$7e
2aab : 8d0302                   sta abst
2aae :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2aae : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ab0 : 48              >            pha         ;use stack to load status
2ab1 : 28              >            plp
                        
2ab2 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2ab5 : 08              >            php         ;save flags
2ab6 : ad0302          >            lda abst
2ab9 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2abc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2abe : 68              >            pla         ;load status
                       >            eor_flag 0
2abf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ac1 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ac4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ac6 : e8                       inx
2ac7 : e002                     cpx #2
2ac9 : d005                     bne tinc3
2acb : a9fe                     lda #$fe
2acd : 8d0302                   sta abst
2ad0 : e005             tinc3   cpx #5
2ad2 : d0da                     bne tinc2
2ad4 : ca                       dex
2ad5 : ee0302                   inc abst
2ad8 :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2ad8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ada : 48              >            pha         ;use stack to load status
2adb : 28              >            plp
                        
2adc : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2adf : 08              >            php         ;save flags
2ae0 : ad0302          >            lda abst
2ae3 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ae6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ae8 : 68              >            pla         ;load status
                       >            eor_flag 0
2ae9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2aeb : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2aee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2af0 : ca                       dex
2af1 : 300b                     bmi tdec3
2af3 : e001                     cpx #1
2af5 : d0e1                     bne tdec2
2af7 : a981                     lda #$81
2af9 : 8d0302                   sta abst
2afc : d0da                     bne tdec2
2afe :                  tdec3
2afe : a200                     ldx #0
2b00 : a97e                     lda #$7e
2b02 : 8d0302                   sta abst
2b05 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b05 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b07 : 48              >            pha         ;use stack to load status
2b08 : 28              >            plp
                        
2b09 : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b0c : 08              >            php         ;save flags
2b0d : ad0302          >            lda abst
2b10 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b15 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b16 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b18 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b1d : e8                       inx
2b1e : e002                     cpx #2
2b20 : d005                     bne tinc13
2b22 : a9fe                     lda #$fe
2b24 : 8d0302                   sta abst
2b27 : e005             tinc13   cpx #5
2b29 : d0da                     bne tinc12
2b2b : ca                       dex
2b2c : ee0302                   inc abst
2b2f :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2b2f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b31 : 48              >            pha         ;use stack to load status
2b32 : 28              >            plp
                        
2b33 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2b36 : 08              >            php         ;save flags
2b37 : ad0302          >            lda abst
2b3a : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b3f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b40 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b42 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b47 : ca                       dex
2b48 : 300b                     bmi tdec13
2b4a : e001                     cpx #1
2b4c : d0e1                     bne tdec12
2b4e : a981                     lda #$81
2b50 : 8d0302                   sta abst
2b53 : d0da                     bne tdec12
2b55 :                  tdec13
                                next_test
2b55 : ad0002          >            lda test_case   ;previous test
2b58 : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2b5c : a924            >            lda #test_num   ;*** next tests' number
2b5e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2b61 : a200                     ldx #0
2b63 : a97e                     lda #$7e
2b65 : 950c             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2b67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b69 : 48              >            pha         ;use stack to load status
2b6a : 28              >            plp
                        
2b6b : f60c                     inc zpt,x
                                tst_zx rINC,fINC,0
2b6d : 08              >            php         ;save flags
2b6e : b50c            >            lda zpt,x
2b70 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b75 : 68              >            pla         ;load status
                       >            eor_flag 0
2b76 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b78 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b7d : b50c                     lda zpt,x
2b7f : e8                       inx
2b80 : e002                     cpx #2
2b82 : d002                     bne tinc5
2b84 : a9fe                     lda #$fe
2b86 : e005             tinc5   cpx #5
2b88 : d0db                     bne tinc4
2b8a : ca                       dex
2b8b : a902                     lda #2
2b8d : 950c             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2b8f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b91 : 48              >            pha         ;use stack to load status
2b92 : 28              >            plp
                        
2b93 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,0
2b95 : 08              >            php         ;save flags
2b96 : b50c            >            lda zpt,x
2b98 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b9d : 68              >            pla         ;load status
                       >            eor_flag 0
2b9e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ba0 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ba3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ba5 : b50c                     lda zpt,x
2ba7 : ca                       dex
2ba8 : 3008                     bmi tdec5
2baa : e001                     cpx #1
2bac : d0df                     bne tdec4
2bae : a981                     lda #$81
2bb0 : d0db                     bne tdec4
2bb2 :                  tdec5
2bb2 : a200                     ldx #0
2bb4 : a97e                     lda #$7e
2bb6 : 950c             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2bb8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2bba : 48              >            pha         ;use stack to load status
2bbb : 28              >            plp
                        
2bbc : f60c                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2bbe : 08              >            php         ;save flags
2bbf : b50c            >            lda zpt,x
2bc1 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bc6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bc7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bc9 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bce : b50c                     lda zpt,x
2bd0 : e8                       inx
2bd1 : e002                     cpx #2
2bd3 : d002                     bne tinc15
2bd5 : a9fe                     lda #$fe
2bd7 : e005             tinc15  cpx #5
2bd9 : d0db                     bne tinc14
2bdb : ca                       dex
2bdc : a902                     lda #2
2bde : 950c             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2be0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2be2 : 48              >            pha         ;use stack to load status
2be3 : 28              >            plp
                        
2be4 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2be6 : 08              >            php         ;save flags
2be7 : b50c            >            lda zpt,x
2be9 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bee : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bef : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bf1 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bf4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bf6 : b50c                     lda zpt,x
2bf8 : ca                       dex
2bf9 : 3008                     bmi tdec15
2bfb : e001                     cpx #1
2bfd : d0df                     bne tdec14
2bff : a981                     lda #$81
2c01 : d0db                     bne tdec14
2c03 :                  tdec15
                                next_test
2c03 : ad0002          >            lda test_case   ;previous test
2c06 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c0a : a925            >            lda #test_num   ;*** next tests' number
2c0c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c0f : a200                     ldx #0
2c11 : a97e                     lda #$7e
2c13 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c16 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c18 : 48              >            pha         ;use stack to load status
2c19 : 28              >            plp
                        
2c1a : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2c1d : 08              >            php         ;save flags
2c1e : bd0302          >            lda abst,x
2c21 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c26 : 68              >            pla         ;load status
                       >            eor_flag 0
2c27 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c29 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c2e : bd0302                   lda abst,x
2c31 : e8                       inx
2c32 : e002                     cpx #2
2c34 : d002                     bne tinc7
2c36 : a9fe                     lda #$fe
2c38 : e005             tinc7   cpx #5
2c3a : d0d7                     bne tinc6
2c3c : ca                       dex
2c3d : a902                     lda #2
2c3f : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2c42 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c44 : 48              >            pha         ;use stack to load status
2c45 : 28              >            plp
                        
2c46 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2c49 : 08              >            php         ;save flags
2c4a : bd0302          >            lda abst,x
2c4d : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c52 : 68              >            pla         ;load status
                       >            eor_flag 0
2c53 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c55 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c5a : bd0302                   lda abst,x
2c5d : ca                       dex
2c5e : 3008                     bmi tdec7
2c60 : e001                     cpx #1
2c62 : d0db                     bne tdec6
2c64 : a981                     lda #$81
2c66 : d0d7                     bne tdec6
2c68 :                  tdec7
2c68 : a200                     ldx #0
2c6a : a97e                     lda #$7e
2c6c : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2c6f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c71 : 48              >            pha         ;use stack to load status
2c72 : 28              >            plp
                        
2c73 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2c76 : 08              >            php         ;save flags
2c77 : bd0302          >            lda abst,x
2c7a : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c7f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c80 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c82 : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c87 : bd0302                   lda abst,x
2c8a : e8                       inx
2c8b : e002                     cpx #2
2c8d : d002                     bne tinc17
2c8f : a9fe                     lda #$fe
2c91 : e005             tinc17  cpx #5
2c93 : d0d7                     bne tinc16
2c95 : ca                       dex
2c96 : a902                     lda #2
2c98 : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2c9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c9d : 48              >            pha         ;use stack to load status
2c9e : 28              >            plp
                        
2c9f : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2ca2 : 08              >            php         ;save flags
2ca3 : bd0302          >            lda abst,x
2ca6 : dd3102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ca9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cab : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cac : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cae : dd3602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cb3 : bd0302                   lda abst,x
2cb6 : ca                       dex
2cb7 : 3008                     bmi tdec17
2cb9 : e001                     cpx #1
2cbb : d0db                     bne tdec16
2cbd : a981                     lda #$81
2cbf : d0d7                     bne tdec16
2cc1 :                  tdec17
                                next_test
2cc1 : ad0002          >            lda test_case   ;previous test
2cc4 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2cc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2cc8 : a926            >            lda #test_num   ;*** next tests' number
2cca : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2ccd : a203                     ldx #3      ;immediate - self modifying code
2ccf : b51c             tand    lda zpAN,x
2cd1 : 8ddc2c                   sta tandi1
                                set_ax  absANa,0
                       >            load_flag 0
2cd4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cd6 : 48              >            pha         ;use stack to load status
2cd7 : bd4b02          >            lda absANa,x    ;precharge accu
2cda : 28              >            plp
                        
2cdc =                  tandi1  equ *+1     ;target for immediate operand
2cdb : 2963                     and #99
                                tst_ax  absrlo,absflo,0
2cdd : 08              >            php         ;save flags
2cde : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ce1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ce3 : 68              >            pla         ;load status
                       >            eor_flag 0
2ce4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ce6 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ce9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ceb : ca                       dex
2cec : 10e1                     bpl tand
2cee : a203                     ldx #3
2cf0 : b51c             tand1   lda zpAN,x
2cf2 : 8dfd2c                   sta tandi2
                                set_ax  absANa,$ff
                       >            load_flag $ff
2cf5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cf7 : 48              >            pha         ;use stack to load status
2cf8 : bd4b02          >            lda absANa,x    ;precharge accu
2cfb : 28              >            plp
                        
2cfd =                  tandi2  equ *+1     ;target for immediate operand
2cfc : 2963                     and #99
                                tst_ax  absrlo,absflo,$ff-fnz
2cfe : 08              >            php         ;save flags
2cff : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d04 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d05 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d07 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d0c : ca                       dex
2d0d : 10e1                     bpl tand1
                        
2d0f : a203                     ldx #3      ;zp
2d11 : b51c             tand2    lda zpAN,x
2d13 : 850c                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d15 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d17 : 48              >            pha         ;use stack to load status
2d18 : bd4b02          >            lda absANa,x    ;precharge accu
2d1b : 28              >            plp
                        
2d1c : 250c                     and zpt
                                tst_ax  absrlo,absflo,0
2d1e : 08              >            php         ;save flags
2d1f : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d24 : 68              >            pla         ;load status
                       >            eor_flag 0
2d25 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d27 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d2c : ca                       dex
2d2d : 10e2                     bpl tand2
2d2f : a203                     ldx #3
2d31 : b51c             tand3   lda zpAN,x
2d33 : 850c                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d35 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d37 : 48              >            pha         ;use stack to load status
2d38 : bd4b02          >            lda absANa,x    ;precharge accu
2d3b : 28              >            plp
                        
2d3c : 250c                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2d3e : 08              >            php         ;save flags
2d3f : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d44 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d45 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d47 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d4c : ca                       dex
2d4d : 10e2                     bpl tand3
                        
2d4f : a203                     ldx #3      ;abs
2d51 : b51c             tand4   lda zpAN,x
2d53 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2d56 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d58 : 48              >            pha         ;use stack to load status
2d59 : bd4b02          >            lda absANa,x    ;precharge accu
2d5c : 28              >            plp
                        
2d5d : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2d60 : 08              >            php         ;save flags
2d61 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d66 : 68              >            pla         ;load status
                       >            eor_flag 0
2d67 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d69 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d6e : ca                       dex
2d6f : 10e0                     bpl tand4
2d71 : a203                     ldx #3
2d73 : b51c             tand5   lda zpAN,x
2d75 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d78 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d7a : 48              >            pha         ;use stack to load status
2d7b : bd4b02          >            lda absANa,x    ;precharge accu
2d7e : 28              >            plp
                        
2d7f : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2d82 : 08              >            php         ;save flags
2d83 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d88 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d89 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d8b : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d90 : ca                       dex
2d91 : 1002                     bpl tand6
                        
2d93 : a203                     ldx #3      ;zp,x
2d95 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2d95 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d97 : 48              >            pha         ;use stack to load status
2d98 : bd4b02          >            lda absANa,x    ;precharge accu
2d9b : 28              >            plp
                        
2d9c : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2d9e : 08              >            php         ;save flags
2d9f : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2da2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2da4 : 68              >            pla         ;load status
                       >            eor_flag 0
2da5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2da7 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2daa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dac : ca                       dex
2dad : 10e6                     bpl tand6
2daf : a203                     ldx #3
2db1 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2db1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2db3 : 48              >            pha         ;use stack to load status
2db4 : bd4b02          >            lda absANa,x    ;precharge accu
2db7 : 28              >            plp
                        
2db8 : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2dba : 08              >            php         ;save flags
2dbb : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dc0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dc1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dc3 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dc8 : ca                       dex
2dc9 : 10e6                     bpl tand7
                        
2dcb : a203                     ldx #3      ;abs,x
2dcd :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2dcd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dcf : 48              >            pha         ;use stack to load status
2dd0 : bd4b02          >            lda absANa,x    ;precharge accu
2dd3 : 28              >            plp
                        
2dd4 : 3d3f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2dd7 : 08              >            php         ;save flags
2dd8 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ddb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ddd : 68              >            pla         ;load status
                       >            eor_flag 0
2dde : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2de0 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2de3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2de5 : ca                       dex
2de6 : 10e5                     bpl tand8
2de8 : a203                     ldx #3
2dea :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2dea : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dec : 48              >            pha         ;use stack to load status
2ded : bd4b02          >            lda absANa,x    ;precharge accu
2df0 : 28              >            plp
                        
2df1 : 3d3f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2df4 : 08              >            php         ;save flags
2df5 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2df8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dfa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dfb : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dfd : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e02 : ca                       dex
2e03 : 10e5                     bpl tand9
                        
2e05 : a003                     ldy #3      ;abs,y
2e07 :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e07 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e09 : 48              >            pha         ;use stack to load status
2e0a : b94b02          >            lda absANa,y    ;precharge accu
2e0d : 28              >            plp
                        
2e0e : 393f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e11 : 08              >            php         ;save flags
2e12 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e17 : 68              >            pla         ;load status
                       >            eor_flag 0
2e18 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e1a : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e1f : 88                       dey
2e20 : 10e5                     bpl tand10
2e22 : a003                     ldy #3
2e24 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e24 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e26 : 48              >            pha         ;use stack to load status
2e27 : b94b02          >            lda absANa,y    ;precharge accu
2e2a : 28              >            plp
                        
2e2b : 393f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2e2e : 08              >            php         ;save flags
2e2f : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e34 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e35 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e37 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e3c : 88                       dey
2e3d : 10e5                     bpl tand11
                        
2e3f : a206                     ldx #6      ;(zp,x)
2e41 : a003                     ldy #3
2e43 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2e43 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e45 : 48              >            pha         ;use stack to load status
2e46 : b94b02          >            lda absANa,y    ;precharge accu
2e49 : 28              >            plp
                        
2e4a : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2e4c : 08              >            php         ;save flags
2e4d : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e52 : 68              >            pla         ;load status
                       >            eor_flag 0
2e53 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e55 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e5a : ca                       dex
2e5b : ca                       dex
2e5c : 88                       dey
2e5d : 10e4                     bpl tand12
2e5f : a206                     ldx #6
2e61 : a003                     ldy #3
2e63 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e65 : 48              >            pha         ;use stack to load status
2e66 : b94b02          >            lda absANa,y    ;precharge accu
2e69 : 28              >            plp
                        
2e6a : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2e6c : 08              >            php         ;save flags
2e6d : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e72 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e73 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e75 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e7a : ca                       dex
2e7b : ca                       dex
2e7c : 88                       dey
2e7d : 10e4                     bpl tand13
                        
2e7f : a003                     ldy #3      ;(zp),y
2e81 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2e81 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e83 : 48              >            pha         ;use stack to load status
2e84 : b94b02          >            lda absANa,y    ;precharge accu
2e87 : 28              >            plp
                        
2e88 : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2e8a : 08              >            php         ;save flags
2e8b : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e90 : 68              >            pla         ;load status
                       >            eor_flag 0
2e91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e93 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e98 : 88                       dey
2e99 : 10e6                     bpl tand14
2e9b : a003                     ldy #3
2e9d :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e9d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e9f : 48              >            pha         ;use stack to load status
2ea0 : b94b02          >            lda absANa,y    ;precharge accu
2ea3 : 28              >            plp
                        
2ea4 : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2ea6 : 08              >            php         ;save flags
2ea7 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2eaa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ead : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2eaf : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2eb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eb4 : 88                       dey
2eb5 : 10e6                     bpl tand15
                                next_test
2eb7 : ad0002          >            lda test_case   ;previous test
2eba : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ebc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2ebe : a927            >            lda #test_num   ;*** next tests' number
2ec0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2ec3 : a203                     ldx #3      ;immediate - self modifying code
2ec5 : b520             teor    lda zpEO,x
2ec7 : 8dd22e                   sta teori1
                                set_ax  absEOa,0
                       >            load_flag 0
2eca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ecc : 48              >            pha         ;use stack to load status
2ecd : bd4f02          >            lda absEOa,x    ;precharge accu
2ed0 : 28              >            plp
                        
2ed2 =                  teori1  equ *+1     ;target for immediate operand
2ed1 : 4963                     eor #99
                                tst_ax  absrlo,absflo,0
2ed3 : 08              >            php         ;save flags
2ed4 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ed7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ed9 : 68              >            pla         ;load status
                       >            eor_flag 0
2eda : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2edc : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2edf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ee1 : ca                       dex
2ee2 : 10e1                     bpl teor
2ee4 : a203                     ldx #3
2ee6 : b520             teor1   lda zpEO,x
2ee8 : 8df32e                   sta teori2
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2eeb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2eed : 48              >            pha         ;use stack to load status
2eee : bd4f02          >            lda absEOa,x    ;precharge accu
2ef1 : 28              >            plp
                        
2ef3 =                  teori2  equ *+1     ;target for immediate operand
2ef2 : 4963                     eor #99
                                tst_ax  absrlo,absflo,$ff-fnz
2ef4 : 08              >            php         ;save flags
2ef5 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ef8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2efa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2efb : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2efd : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f02 : ca                       dex
2f03 : 10e1                     bpl teor1
                        
2f05 : a203                     ldx #3      ;zp
2f07 : b520             teor2    lda zpEO,x
2f09 : 850c                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f0b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f0d : 48              >            pha         ;use stack to load status
2f0e : bd4f02          >            lda absEOa,x    ;precharge accu
2f11 : 28              >            plp
                        
2f12 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,0
2f14 : 08              >            php         ;save flags
2f15 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f1a : 68              >            pla         ;load status
                       >            eor_flag 0
2f1b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f1d : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f22 : ca                       dex
2f23 : 10e2                     bpl teor2
2f25 : a203                     ldx #3
2f27 : b520             teor3   lda zpEO,x
2f29 : 850c                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f2b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f2d : 48              >            pha         ;use stack to load status
2f2e : bd4f02          >            lda absEOa,x    ;precharge accu
2f31 : 28              >            plp
                        
2f32 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2f34 : 08              >            php         ;save flags
2f35 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f3a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f3b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f3d : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f42 : ca                       dex
2f43 : 10e2                     bpl teor3
                        
2f45 : a203                     ldx #3      ;abs
2f47 : b520             teor4   lda zpEO,x
2f49 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2f4c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f4e : 48              >            pha         ;use stack to load status
2f4f : bd4f02          >            lda absEOa,x    ;precharge accu
2f52 : 28              >            plp
                        
2f53 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2f56 : 08              >            php         ;save flags
2f57 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f5c : 68              >            pla         ;load status
                       >            eor_flag 0
2f5d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f5f : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f64 : ca                       dex
2f65 : 10e0                     bpl teor4
2f67 : a203                     ldx #3
2f69 : b520             teor5   lda zpEO,x
2f6b : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f6e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f70 : 48              >            pha         ;use stack to load status
2f71 : bd4f02          >            lda absEOa,x    ;precharge accu
2f74 : 28              >            plp
                        
2f75 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2f78 : 08              >            php         ;save flags
2f79 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f7e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f7f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f81 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f86 : ca                       dex
2f87 : 1002                     bpl teor6
                        
2f89 : a203                     ldx #3      ;zp,x
2f8b :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2f8b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f8d : 48              >            pha         ;use stack to load status
2f8e : bd4f02          >            lda absEOa,x    ;precharge accu
2f91 : 28              >            plp
                        
2f92 : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2f94 : 08              >            php         ;save flags
2f95 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f9a : 68              >            pla         ;load status
                       >            eor_flag 0
2f9b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f9d : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fa0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fa2 : ca                       dex
2fa3 : 10e6                     bpl teor6
2fa5 : a203                     ldx #3
2fa7 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fa7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fa9 : 48              >            pha         ;use stack to load status
2faa : bd4f02          >            lda absEOa,x    ;precharge accu
2fad : 28              >            plp
                        
2fae : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2fb0 : 08              >            php         ;save flags
2fb1 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fb6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fb7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fb9 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fbe : ca                       dex
2fbf : 10e6                     bpl teor7
                        
2fc1 : a203                     ldx #3      ;abs,x
2fc3 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2fc3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fc5 : 48              >            pha         ;use stack to load status
2fc6 : bd4f02          >            lda absEOa,x    ;precharge accu
2fc9 : 28              >            plp
                        
2fca : 5d4302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
2fcd : 08              >            php         ;save flags
2fce : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fd3 : 68              >            pla         ;load status
                       >            eor_flag 0
2fd4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fd6 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fd9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fdb : ca                       dex
2fdc : 10e5                     bpl teor8
2fde : a203                     ldx #3
2fe0 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fe0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fe2 : 48              >            pha         ;use stack to load status
2fe3 : bd4f02          >            lda absEOa,x    ;precharge accu
2fe6 : 28              >            plp
                        
2fe7 : 5d4302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2fea : 08              >            php         ;save flags
2feb : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ff0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ff1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ff3 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ff6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ff8 : ca                       dex
2ff9 : 10e5                     bpl teor9
                        
2ffb : a003                     ldy #3      ;abs,y
2ffd :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
2ffd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fff : 48              >            pha         ;use stack to load status
3000 : b94f02          >            lda absEOa,y    ;precharge accu
3003 : 28              >            plp
                        
3004 : 594302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
3007 : 08              >            php         ;save flags
3008 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
300b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
300d : 68              >            pla         ;load status
                       >            eor_flag 0
300e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3010 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3013 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3015 : 88                       dey
3016 : 10e5                     bpl teor10
3018 : a003                     ldy #3
301a :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
301a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
301c : 48              >            pha         ;use stack to load status
301d : b94f02          >            lda absEOa,y    ;precharge accu
3020 : 28              >            plp
                        
3021 : 594302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
3024 : 08              >            php         ;save flags
3025 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3028 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
302a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
302b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
302d : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3030 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3032 : 88                       dey
3033 : 10e5                     bpl teor11
                        
3035 : a206                     ldx #6      ;(zp,x)
3037 : a003                     ldy #3
3039 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
3039 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
303b : 48              >            pha         ;use stack to load status
303c : b94f02          >            lda absEOa,y    ;precharge accu
303f : 28              >            plp
                        
3040 : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3042 : 08              >            php         ;save flags
3043 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3046 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3048 : 68              >            pla         ;load status
                       >            eor_flag 0
3049 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
304b : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
304e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3050 : ca                       dex
3051 : ca                       dex
3052 : 88                       dey
3053 : 10e4                     bpl teor12
3055 : a206                     ldx #6
3057 : a003                     ldy #3
3059 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3059 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
305b : 48              >            pha         ;use stack to load status
305c : b94f02          >            lda absEOa,y    ;precharge accu
305f : 28              >            plp
                        
3060 : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3062 : 08              >            php         ;save flags
3063 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3066 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3068 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3069 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
306b : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
306e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3070 : ca                       dex
3071 : ca                       dex
3072 : 88                       dey
3073 : 10e4                     bpl teor13
                        
3075 : a003                     ldy #3      ;(zp),y
3077 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
3077 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3079 : 48              >            pha         ;use stack to load status
307a : b94f02          >            lda absEOa,y    ;precharge accu
307d : 28              >            plp
                        
307e : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
3080 : 08              >            php         ;save flags
3081 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3084 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3086 : 68              >            pla         ;load status
                       >            eor_flag 0
3087 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3089 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
308c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
308e : 88                       dey
308f : 10e6                     bpl teor14
3091 : a003                     ldy #3
3093 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3093 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3095 : 48              >            pha         ;use stack to load status
3096 : b94f02          >            lda absEOa,y    ;precharge accu
3099 : 28              >            plp
                        
309a : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
309c : 08              >            php         ;save flags
309d : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30a2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30a3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30a5 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
30a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30aa : 88                       dey
30ab : 10e6                     bpl teor15
                                next_test
30ad : ad0002          >            lda test_case   ;previous test
30b0 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
30b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
30b4 : a928            >            lda #test_num   ;*** next tests' number
30b6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
30b9 : a203                     ldx #3      ;immediate - self modifying code
30bb : b518             tora    lda zpOR,x
30bd : 8dc830                   sta torai1
                                set_ax  absORa,0
                       >            load_flag 0
30c0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30c2 : 48              >            pha         ;use stack to load status
30c3 : bd4702          >            lda absORa,x    ;precharge accu
30c6 : 28              >            plp
                        
30c8 =                  torai1  equ *+1     ;target for immediate operand
30c7 : 0963                     ora #99
                                tst_ax  absrlo,absflo,0
30c9 : 08              >            php         ;save flags
30ca : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30cf : 68              >            pla         ;load status
                       >            eor_flag 0
30d0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30d2 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30d7 : ca                       dex
30d8 : 10e1                     bpl tora
30da : a203                     ldx #3
30dc : b518             tora1   lda zpOR,x
30de : 8de930                   sta torai2
                                set_ax  absORa,$ff
                       >            load_flag $ff
30e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30e3 : 48              >            pha         ;use stack to load status
30e4 : bd4702          >            lda absORa,x    ;precharge accu
30e7 : 28              >            plp
                        
30e9 =                  torai2  equ *+1     ;target for immediate operand
30e8 : 0963                     ora #99
                                tst_ax  absrlo,absflo,$ff-fnz
30ea : 08              >            php         ;save flags
30eb : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30f0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30f1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30f3 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30f8 : ca                       dex
30f9 : 10e1                     bpl tora1
                        
30fb : a203                     ldx #3      ;zp
30fd : b518             tora2    lda zpOR,x
30ff : 850c                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3101 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3103 : 48              >            pha         ;use stack to load status
3104 : bd4702          >            lda absORa,x    ;precharge accu
3107 : 28              >            plp
                        
3108 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,0
310a : 08              >            php         ;save flags
310b : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
310e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3110 : 68              >            pla         ;load status
                       >            eor_flag 0
3111 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3113 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3116 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3118 : ca                       dex
3119 : 10e2                     bpl tora2
311b : a203                     ldx #3
311d : b518             tora3   lda zpOR,x
311f : 850c                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3121 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3123 : 48              >            pha         ;use stack to load status
3124 : bd4702          >            lda absORa,x    ;precharge accu
3127 : 28              >            plp
                        
3128 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
312a : 08              >            php         ;save flags
312b : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
312e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3130 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3131 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3133 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3136 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3138 : ca                       dex
3139 : 10e2                     bpl tora3
                        
313b : a203                     ldx #3      ;abs
313d : b518             tora4   lda zpOR,x
313f : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
3142 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3144 : 48              >            pha         ;use stack to load status
3145 : bd4702          >            lda absORa,x    ;precharge accu
3148 : 28              >            plp
                        
3149 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
314c : 08              >            php         ;save flags
314d : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3150 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3152 : 68              >            pla         ;load status
                       >            eor_flag 0
3153 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3155 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3158 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
315a : ca                       dex
315b : 10e0                     bpl tora4
315d : a203                     ldx #3
315f : b518             tora5   lda zpOR,x
3161 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
3164 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3166 : 48              >            pha         ;use stack to load status
3167 : bd4702          >            lda absORa,x    ;precharge accu
316a : 28              >            plp
                        
316b : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
316e : 08              >            php         ;save flags
316f : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3172 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3174 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3175 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3177 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
317a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
317c : ca                       dex
317d : 1002                     bpl tora6
                        
317f : a203                     ldx #3      ;zp,x
3181 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
3181 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3183 : 48              >            pha         ;use stack to load status
3184 : bd4702          >            lda absORa,x    ;precharge accu
3187 : 28              >            plp
                        
3188 : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
318a : 08              >            php         ;save flags
318b : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
318e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3190 : 68              >            pla         ;load status
                       >            eor_flag 0
3191 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3193 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3196 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3198 : ca                       dex
3199 : 10e6                     bpl tora6
319b : a203                     ldx #3
319d :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
319d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
319f : 48              >            pha         ;use stack to load status
31a0 : bd4702          >            lda absORa,x    ;precharge accu
31a3 : 28              >            plp
                        
31a4 : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31a6 : 08              >            php         ;save flags
31a7 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31ac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31ad : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31af : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31b4 : ca                       dex
31b5 : 10e6                     bpl tora7
                        
31b7 : a203                     ldx #3      ;abs,x
31b9 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
31b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31bb : 48              >            pha         ;use stack to load status
31bc : bd4702          >            lda absORa,x    ;precharge accu
31bf : 28              >            plp
                        
31c0 : 1d3b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
31c3 : 08              >            php         ;save flags
31c4 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31c9 : 68              >            pla         ;load status
                       >            eor_flag 0
31ca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31cc : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31d1 : ca                       dex
31d2 : 10e5                     bpl tora8
31d4 : a203                     ldx #3
31d6 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
31d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31d8 : 48              >            pha         ;use stack to load status
31d9 : bd4702          >            lda absORa,x    ;precharge accu
31dc : 28              >            plp
                        
31dd : 1d3b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31e0 : 08              >            php         ;save flags
31e1 : dd5302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31e6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31e7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31e9 : dd5702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31ee : ca                       dex
31ef : 10e5                     bpl tora9
                        
31f1 : a003                     ldy #3      ;abs,y
31f3 :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
31f3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31f5 : 48              >            pha         ;use stack to load status
31f6 : b94702          >            lda absORa,y    ;precharge accu
31f9 : 28              >            plp
                        
31fa : 193b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
31fd : 08              >            php         ;save flags
31fe : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3201 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3203 : 68              >            pla         ;load status
                       >            eor_flag 0
3204 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3206 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3209 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
320b : 88                       dey
320c : 10e5                     bpl tora10
320e : a003                     ldy #3
3210 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3210 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3212 : 48              >            pha         ;use stack to load status
3213 : b94702          >            lda absORa,y    ;precharge accu
3216 : 28              >            plp
                        
3217 : 193b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
321a : 08              >            php         ;save flags
321b : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
321e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3220 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3221 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3223 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3226 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3228 : 88                       dey
3229 : 10e5                     bpl tora11
                        
322b : a206                     ldx #6      ;(zp,x)
322d : a003                     ldy #3
322f :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
322f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3231 : 48              >            pha         ;use stack to load status
3232 : b94702          >            lda absORa,y    ;precharge accu
3235 : 28              >            plp
                        
3236 : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3238 : 08              >            php         ;save flags
3239 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
323c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
323e : 68              >            pla         ;load status
                       >            eor_flag 0
323f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3241 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3244 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3246 : ca                       dex
3247 : ca                       dex
3248 : 88                       dey
3249 : 10e4                     bpl tora12
324b : a206                     ldx #6
324d : a003                     ldy #3
324f :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
324f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3251 : 48              >            pha         ;use stack to load status
3252 : b94702          >            lda absORa,y    ;precharge accu
3255 : 28              >            plp
                        
3256 : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3258 : 08              >            php         ;save flags
3259 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
325c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
325e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
325f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3261 : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3264 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3266 : ca                       dex
3267 : ca                       dex
3268 : 88                       dey
3269 : 10e4                     bpl tora13
                        
326b : a003                     ldy #3      ;(zp),y
326d :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
326d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
326f : 48              >            pha         ;use stack to load status
3270 : b94702          >            lda absORa,y    ;precharge accu
3273 : 28              >            plp
                        
3274 : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
3276 : 08              >            php         ;save flags
3277 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
327a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
327c : 68              >            pla         ;load status
                       >            eor_flag 0
327d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
327f : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3282 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3284 : 88                       dey
3285 : 10e6                     bpl tora14
3287 : a003                     ldy #3
3289 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
3289 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
328b : 48              >            pha         ;use stack to load status
328c : b94702          >            lda absORa,y    ;precharge accu
328f : 28              >            plp
                        
3290 : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
3292 : 08              >            php         ;save flags
3293 : d95302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3296 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3298 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3299 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
329b : d95702          >            cmp absflo,y    ;test flags
                       >            trap_ne
329e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32a0 : 88                       dey
32a1 : 10e6                     bpl tora15
                            if I_flag = 3
32a3 : 58                       cli
                            endif                
                                next_test
32a4 : ad0002          >            lda test_case   ;previous test
32a7 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
32a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
32ab : a929            >            lda #test_num   ;*** next tests' number
32ad : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
32b0 : d8                       cld
32b1 : a20e                     ldx #ad2        ;for indexed test
32b3 : a0ff                     ldy #$ff        ;max range
32b5 : a900                     lda #0          ;start with adding zeroes & no carry
32b7 : 850c                     sta adfc        ;carry in - for diag
32b9 : 850d                     sta ad1         ;operand 1 - accumulator
32bb : 850e                     sta ad2         ;operand 2 - memory or immediate
32bd : 8d0302                   sta ada2        ;non zp
32c0 : 850f                     sta adrl        ;expected result bits 0-7
32c2 : 8510                     sta adrh        ;expected result bit 8 (carry out)
32c4 : a9ff                     lda #$ff        ;complemented operand 2 for subtract
32c6 : 8512                     sta sb2
32c8 : 8d0402                   sta sba2        ;non zp
32cb : a902                     lda #2          ;expected Z-flag
32cd : 8511                     sta adrf
32cf : 18               tadd    clc             ;test with carry clear
32d0 : 20f134                   jsr chkadd
32d3 : e60c                     inc adfc        ;now with carry
32d5 : e60f                     inc adrl        ;result +1
32d7 : 08                       php             ;save N & Z from low result
32d8 : 08                       php
32d9 : 68                       pla             ;accu holds expected flags
32da : 2982                     and #$82        ;mask N & Z
32dc : 28                       plp
32dd : d002                     bne tadd1
32df : e610                     inc adrh        ;result bit 8 - carry
32e1 : 0510             tadd1   ora adrh        ;merge C to expected flags
32e3 : 8511                     sta adrf        ;save expected flags except overflow
32e5 : 38                       sec             ;test with carry set
32e6 : 20f134                   jsr chkadd
32e9 : c60c                     dec adfc        ;same for operand +1 but no carry
32eb : e60d                     inc ad1
32ed : d0e0                     bne tadd        ;iterate op1
32ef : a900                     lda #0          ;preset result to op2 when op1 = 0
32f1 : 8510                     sta adrh
32f3 : ee0302                   inc ada2
32f6 : e60e                     inc ad2
32f8 : 08                       php             ;save NZ as operand 2 becomes the new result
32f9 : 68                       pla
32fa : 2982                     and #$82        ;mask N00000Z0
32fc : 8511                     sta adrf        ;no need to check carry as we are adding to 0
32fe : c612                     dec sb2         ;complement subtract operand 2
3300 : ce0402                   dec sba2
3303 : a50e                     lda ad2         
3305 : 850f                     sta adrl
3307 : d0c6                     bne tadd        ;iterate op2
                                next_test
3309 : ad0002          >            lda test_case   ;previous test
330c : c929            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
330e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002a =                 >test_num = test_num + 1
3310 : a92a            >            lda #test_num   ;*** next tests' number
3312 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
3315 : f8                       sed 
3316 : a20e                     ldx #ad2        ;for indexed test
3318 : a0ff                     ldy #$ff        ;max range
331a : a999                     lda #$99        ;start with adding 99 to 99 with carry
331c : 850d                     sta ad1         ;operand 1 - accumulator
331e : 850e                     sta ad2         ;operand 2 - memory or immediate
3320 : 8d0302                   sta ada2        ;non zp
3323 : 850f                     sta adrl        ;expected result bits 0-7
3325 : a901                     lda #1          ;set carry in & out
3327 : 850c                     sta adfc        ;carry in - for diag
3329 : 8510                     sta adrh        ;expected result bit 8 (carry out)
332b : a900                     lda #0          ;complemented operand 2 for subtract
332d : 8512                     sta sb2
332f : 8d0402                   sta sba2        ;non zp
3332 : 38               tdad    sec             ;test with carry set
3333 : 20c033                   jsr chkdad
3336 : c60c                     dec adfc        ;now with carry clear
3338 : a50f                     lda adrl        ;decimal adjust result
333a : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
333c : c610                     dec adrh
333e : a999                     lda #$99
3340 : 850f                     sta adrl
3342 : d012                     bne tdad3
3344 : 290f             tdad1   and #$f         ;lower nibble mask
3346 : d00c                     bne tdad2       ;no decimal adjust needed
3348 : c60f                     dec adrl        ;decimal adjust (?0-6)
334a : c60f                     dec adrl
334c : c60f                     dec adrl
334e : c60f                     dec adrl
3350 : c60f                     dec adrl
3352 : c60f                     dec adrl
3354 : c60f             tdad2   dec adrl        ;result -1
3356 : 18               tdad3   clc             ;test with carry clear
3357 : 20c033                   jsr chkdad
335a : e60c                     inc adfc        ;same for operand -1 but with carry
335c : a50d                     lda ad1         ;decimal adjust operand 1
335e : f015                     beq tdad5       ;iterate operand 2
3360 : 290f                     and #$f         ;lower nibble mask
3362 : d00c                     bne tdad4       ;skip decimal adjust
3364 : c60d                     dec ad1         ;decimal adjust (?0-6)
3366 : c60d                     dec ad1
3368 : c60d                     dec ad1
336a : c60d                     dec ad1
336c : c60d                     dec ad1
336e : c60d                     dec ad1
3370 : c60d             tdad4   dec ad1         ;operand 1 -1
3372 : 4c3233                   jmp tdad        ;iterate op1
                        
3375 : a999             tdad5   lda #$99        ;precharge op1 max
3377 : 850d                     sta ad1
3379 : a50e                     lda ad2         ;decimal adjust operand 2
337b : f030                     beq tdad7       ;end of iteration
337d : 290f                     and #$f         ;lower nibble mask
337f : d018                     bne tdad6       ;skip decimal adjust
3381 : c60e                     dec ad2         ;decimal adjust (?0-6)
3383 : c60e                     dec ad2
3385 : c60e                     dec ad2
3387 : c60e                     dec ad2
3389 : c60e                     dec ad2
338b : c60e                     dec ad2
338d : e612                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
338f : e612                     inc sb2
3391 : e612                     inc sb2
3393 : e612                     inc sb2
3395 : e612                     inc sb2
3397 : e612                     inc sb2
3399 : c60e             tdad6   dec ad2         ;operand 2 -1
339b : e612                     inc sb2         ;complemented operand for subtract
339d : a512                     lda sb2
339f : 8d0402                   sta sba2        ;copy as non zp operand
33a2 : a50e                     lda ad2
33a4 : 8d0302                   sta ada2        ;copy as non zp operand
33a7 : 850f                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
33a9 : e610                     inc adrh        ;result carry
33ab : d085                     bne tdad        ;iterate op2
33ad : d8               tdad7   cld
                        
33ae : ad0002                   lda test_case
33b1 : c92a                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
33b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33b5 : a9f0                     lda #$f0        ;mark opcode testing complete
33b7 : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to 
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************       
                        ; -------------       
                                success         ;if you get here everything went well
33ba : 4cba33          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************ 
33bd : 4c0004                   jmp start       ;run again      
                        
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
33c0 :                  chkdad
                        ; decimal ADC / SBC zp
33c0 : 08                       php             ;save carry for subtract
33c1 : a50d                     lda ad1
33c3 : 650e                     adc ad2         ;perform add
33c5 : 08                       php          
33c6 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ca : 68                       pla             ;check flags
33cb : 2901                     and #1          ;mask carry
33cd : c510                     cmp adrh
                                trap_ne         ;bad carry
33cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
33d1 : 28                       plp
33d2 : 08                       php             ;save carry for next add
33d3 : a50d                     lda ad1
33d5 : e512                     sbc sb2         ;perform subtract
33d7 : 08                       php          
33d8 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33da : d0fe            >        bne *           ;failed not equal (non zero)
                        
33dc : 68                       pla             ;check flags
33dd : 2901                     and #1          ;mask carry
33df : c510                     cmp adrh
                                trap_ne         ;bad flags
33e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33e3 : 28                       plp
                        ; decimal ADC / SBC abs
33e4 : 08                       php             ;save carry for subtract
33e5 : a50d                     lda ad1
33e7 : 6d0302                   adc ada2        ;perform add
33ea : 08                       php          
33eb : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ef : 68                       pla             ;check flags
33f0 : 2901                     and #1          ;mask carry
33f2 : c510                     cmp adrh
                                trap_ne         ;bad carry
33f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33f6 : 28                       plp
33f7 : 08                       php             ;save carry for next add
33f8 : a50d                     lda ad1
33fa : ed0402                   sbc sba2        ;perform subtract
33fd : 08                       php          
33fe : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3400 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3402 : 68                       pla             ;check flags
3403 : 2901                     and #1          ;mask carry
3405 : c510                     cmp adrh
                                trap_ne         ;bad carry
3407 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3409 : 28                       plp
                        ; decimal ADC / SBC #
340a : 08                       php             ;save carry for subtract
340b : a50e                     lda ad2
340d : 8d1334                   sta chkdadi     ;self modify immediate
3410 : a50d                     lda ad1
3413 =                  chkdadi = * + 1         ;operand of the immediate ADC
3412 : 6900                     adc #0          ;perform add
3414 : 08                       php          
3415 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3417 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3419 : 68                       pla             ;check flags
341a : 2901                     and #1          ;mask carry
341c : c510                     cmp adrh
                                trap_ne         ;bad carry
341e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3420 : 28                       plp
3421 : 08                       php             ;save carry for next add
3422 : a512                     lda sb2
3424 : 8d2a34                   sta chkdsbi     ;self modify immediate
3427 : a50d                     lda ad1
342a =                  chkdsbi = * + 1         ;operand of the immediate SBC
3429 : e900                     sbc #0          ;perform subtract
342b : 08                       php          
342c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
342e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3430 : 68                       pla             ;check flags
3431 : 2901                     and #1          ;mask carry
3433 : c510                     cmp adrh
                                trap_ne         ;bad carry
3435 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3437 : 28                       plp
                        ; decimal ADC / SBC zp,x
3438 : 08                       php             ;save carry for subtract
3439 : a50d                     lda ad1
343b : 7500                     adc 0,x         ;perform add
343d : 08                       php          
343e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3440 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3442 : 68                       pla             ;check flags
3443 : 2901                     and #1          ;mask carry
3445 : c510                     cmp adrh
                                trap_ne         ;bad carry
3447 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3449 : 28                       plp
344a : 08                       php             ;save carry for next add
344b : a50d                     lda ad1
344d : f504                     sbc sb2-ad2,x   ;perform subtract
344f : 08                       php          
3450 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3452 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3454 : 68                       pla             ;check flags
3455 : 2901                     and #1          ;mask carry
3457 : c510                     cmp adrh
                                trap_ne         ;bad carry
3459 : d0fe            >        bne *           ;failed not equal (non zero)
                        
345b : 28                       plp
                        ; decimal ADC / SBC abs,x
345c : 08                       php             ;save carry for subtract
345d : a50d                     lda ad1
345f : 7df501                   adc ada2-ad2,x  ;perform add
3462 : 08                       php          
3463 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3465 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3467 : 68                       pla             ;check flags
3468 : 2901                     and #1          ;mask carry
346a : c510                     cmp adrh
                                trap_ne         ;bad carry
346c : d0fe            >        bne *           ;failed not equal (non zero)
                        
346e : 28                       plp
346f : 08                       php             ;save carry for next add
3470 : a50d                     lda ad1
3472 : fdf601                   sbc sba2-ad2,x  ;perform subtract
3475 : 08                       php          
3476 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3478 : d0fe            >        bne *           ;failed not equal (non zero)
                        
347a : 68                       pla             ;check flags
347b : 2901                     and #1          ;mask carry
347d : c510                     cmp adrh
                                trap_ne         ;bad carry
347f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3481 : 28                       plp
                        ; decimal ADC / SBC abs,y
3482 : 08                       php             ;save carry for subtract
3483 : a50d                     lda ad1
3485 : 790401                   adc ada2-$ff,y  ;perform add
3488 : 08                       php          
3489 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
348b : d0fe            >        bne *           ;failed not equal (non zero)
                        
348d : 68                       pla             ;check flags
348e : 2901                     and #1          ;mask carry
3490 : c510                     cmp adrh
                                trap_ne         ;bad carry
3492 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3494 : 28                       plp
3495 : 08                       php             ;save carry for next add
3496 : a50d                     lda ad1
3498 : f90501                   sbc sba2-$ff,y  ;perform subtract
349b : 08                       php          
349c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
349e : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a0 : 68                       pla             ;check flags
34a1 : 2901                     and #1          ;mask carry
34a3 : c510                     cmp adrh
                                trap_ne         ;bad carry
34a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a7 : 28                       plp
                        ; decimal ADC / SBC (zp,x)
34a8 : 08                       php             ;save carry for subtract
34a9 : a50d                     lda ad1
34ab : 6144                     adc (lo adi2-ad2,x) ;perform add
34ad : 08                       php          
34ae : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34b2 : 68                       pla             ;check flags
34b3 : 2901                     and #1          ;mask carry
34b5 : c510                     cmp adrh
                                trap_ne         ;bad carry
34b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34b9 : 28                       plp
34ba : 08                       php             ;save carry for next add
34bb : a50d                     lda ad1
34bd : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
34bf : 08                       php          
34c0 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c4 : 68                       pla             ;check flags
34c5 : 2901                     and #1          ;mask carry
34c7 : c510                     cmp adrh
                                trap_ne         ;bad carry
34c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34cb : 28                       plp
                        ; decimal ADC / SBC (abs),y
34cc : 08                       php             ;save carry for subtract
34cd : a50d                     lda ad1
34cf : 7156                     adc (adiy2),y   ;perform add
34d1 : 08                       php          
34d2 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d6 : 68                       pla             ;check flags
34d7 : 2901                     and #1          ;mask carry
34d9 : c510                     cmp adrh
                                trap_ne         ;bad carry
34db : d0fe            >        bne *           ;failed not equal (non zero)
                        
34dd : 28                       plp
34de : 08                       php             ;save carry for next add
34df : a50d                     lda ad1
34e1 : f158                     sbc (sbiy2),y   ;perform subtract
34e3 : 08                       php          
34e4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34e8 : 68                       pla             ;check flags
34e9 : 2901                     and #1          ;mask carry
34eb : c510                     cmp adrh
                                trap_ne         ;bad carry
34ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
34ef : 28                       plp
34f0 : 60                       rts
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
34f1 : a511             chkadd  lda adrf        ;add V-flag if overflow
34f3 : 2983                     and #$83        ;keep N-----ZC / clear V
34f5 : 48                       pha
34f6 : a50d                     lda ad1         ;test sign unequal between operands
34f8 : 450e                     eor ad2
34fa : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
34fc : a50d                     lda ad1         ;test sign equal between operands and result
34fe : 450f                     eor adrl
3500 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3502 : 68                       pla
3503 : 0940                     ora #$40        ;set V
3505 : 48                       pha
3506 : 68               ckad1   pla
3507 : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
3509 : 08                       php             ;save carry for subtract
350a : a50d                     lda ad1
350c : 650e                     adc ad2         ;perform add
350e : 08                       php          
350f : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3511 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3513 : 68                       pla             ;check flags
3514 : 29c3                     and #$c3        ;mask NV----ZC
3516 : c511                     cmp adrf
                                trap_ne         ;bad flags
3518 : d0fe            >        bne *           ;failed not equal (non zero)
                        
351a : 28                       plp
351b : 08                       php             ;save carry for next add
351c : a50d                     lda ad1
351e : e512                     sbc sb2         ;perform subtract
3520 : 08                       php          
3521 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3523 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3525 : 68                       pla             ;check flags
3526 : 29c3                     and #$c3        ;mask NV----ZC
3528 : c511                     cmp adrf
                                trap_ne         ;bad flags
352a : d0fe            >        bne *           ;failed not equal (non zero)
                        
352c : 28                       plp
                        ; binary ADC / SBC abs
352d : 08                       php             ;save carry for subtract
352e : a50d                     lda ad1
3530 : 6d0302                   adc ada2        ;perform add
3533 : 08                       php          
3534 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3536 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3538 : 68                       pla             ;check flags
3539 : 29c3                     and #$c3        ;mask NV----ZC
353b : c511                     cmp adrf
                                trap_ne         ;bad flags
353d : d0fe            >        bne *           ;failed not equal (non zero)
                        
353f : 28                       plp
3540 : 08                       php             ;save carry for next add
3541 : a50d                     lda ad1
3543 : ed0402                   sbc sba2        ;perform subtract
3546 : 08                       php          
3547 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3549 : d0fe            >        bne *           ;failed not equal (non zero)
                        
354b : 68                       pla             ;check flags
354c : 29c3                     and #$c3        ;mask NV----ZC
354e : c511                     cmp adrf
                                trap_ne         ;bad flags
3550 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3552 : 28                       plp
                        ; binary ADC / SBC #
3553 : 08                       php             ;save carry for subtract
3554 : a50e                     lda ad2
3556 : 8d5c35                   sta chkadi      ;self modify immediate
3559 : a50d                     lda ad1
355c =                  chkadi  = * + 1         ;operand of the immediate ADC
355b : 6900                     adc #0          ;perform add
355d : 08                       php          
355e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3560 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3562 : 68                       pla             ;check flags
3563 : 29c3                     and #$c3        ;mask NV----ZC
3565 : c511                     cmp adrf
                                trap_ne         ;bad flags
3567 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3569 : 28                       plp
356a : 08                       php             ;save carry for next add
356b : a512                     lda sb2
356d : 8d7335                   sta chksbi      ;self modify immediate
3570 : a50d                     lda ad1
3573 =                  chksbi  = * + 1         ;operand of the immediate SBC
3572 : e900                     sbc #0          ;perform subtract
3574 : 08                       php          
3575 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3577 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3579 : 68                       pla             ;check flags
357a : 29c3                     and #$c3        ;mask NV----ZC
357c : c511                     cmp adrf
                                trap_ne         ;bad flags
357e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3580 : 28                       plp
                        ; binary ADC / SBC zp,x
3581 : 08                       php             ;save carry for subtract
3582 : a50d                     lda ad1
3584 : 7500                     adc 0,x         ;perform add
3586 : 08                       php          
3587 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3589 : d0fe            >        bne *           ;failed not equal (non zero)
                        
358b : 68                       pla             ;check flags
358c : 29c3                     and #$c3        ;mask NV----ZC
358e : c511                     cmp adrf
                                trap_ne         ;bad flags
3590 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3592 : 28                       plp
3593 : 08                       php             ;save carry for next add
3594 : a50d                     lda ad1
3596 : f504                     sbc sb2-ad2,x   ;perform subtract
3598 : 08                       php          
3599 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
359b : d0fe            >        bne *           ;failed not equal (non zero)
                        
359d : 68                       pla             ;check flags
359e : 29c3                     and #$c3        ;mask NV----ZC
35a0 : c511                     cmp adrf
                                trap_ne         ;bad flags
35a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a4 : 28                       plp
                        ; binary ADC / SBC abs,x
35a5 : 08                       php             ;save carry for subtract
35a6 : a50d                     lda ad1
35a8 : 7df501                   adc ada2-ad2,x  ;perform add
35ab : 08                       php          
35ac : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b0 : 68                       pla             ;check flags
35b1 : 29c3                     and #$c3        ;mask NV----ZC
35b3 : c511                     cmp adrf
                                trap_ne         ;bad flags
35b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b7 : 28                       plp
35b8 : 08                       php             ;save carry for next add
35b9 : a50d                     lda ad1
35bb : fdf601                   sbc sba2-ad2,x  ;perform subtract
35be : 08                       php          
35bf : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c3 : 68                       pla             ;check flags
35c4 : 29c3                     and #$c3        ;mask NV----ZC
35c6 : c511                     cmp adrf
                                trap_ne         ;bad flags
35c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35ca : 28                       plp
                        ; binary ADC / SBC abs,y
35cb : 08                       php             ;save carry for subtract
35cc : a50d                     lda ad1
35ce : 790401                   adc ada2-$ff,y  ;perform add
35d1 : 08                       php          
35d2 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35d6 : 68                       pla             ;check flags
35d7 : 29c3                     and #$c3        ;mask NV----ZC
35d9 : c511                     cmp adrf
                                trap_ne         ;bad flags
35db : d0fe            >        bne *           ;failed not equal (non zero)
                        
35dd : 28                       plp
35de : 08                       php             ;save carry for next add
35df : a50d                     lda ad1
35e1 : f90501                   sbc sba2-$ff,y  ;perform subtract
35e4 : 08                       php          
35e5 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35e9 : 68                       pla             ;check flags
35ea : 29c3                     and #$c3        ;mask NV----ZC
35ec : c511                     cmp adrf
                                trap_ne         ;bad flags
35ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f0 : 28                       plp
                        ; binary ADC / SBC (zp,x)
35f1 : 08                       php             ;save carry for subtract
35f2 : a50d                     lda ad1
35f4 : 6144                     adc (lo adi2-ad2,x) ;perform add
35f6 : 08                       php          
35f7 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
35f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35fb : 68                       pla             ;check flags
35fc : 29c3                     and #$c3        ;mask NV----ZC
35fe : c511                     cmp adrf
                                trap_ne         ;bad flags
3600 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3602 : 28                       plp
3603 : 08                       php             ;save carry for next add
3604 : a50d                     lda ad1
3606 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
3608 : 08                       php          
3609 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
360b : d0fe            >        bne *           ;failed not equal (non zero)
                        
360d : 68                       pla             ;check flags
360e : 29c3                     and #$c3        ;mask NV----ZC
3610 : c511                     cmp adrf
                                trap_ne         ;bad flags
3612 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3614 : 28                       plp
                        ; binary ADC / SBC (abs),y
3615 : 08                       php             ;save carry for subtract
3616 : a50d                     lda ad1
3618 : 7156                     adc (adiy2),y   ;perform add
361a : 08                       php          
361b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
361d : d0fe            >        bne *           ;failed not equal (non zero)
                        
361f : 68                       pla             ;check flags
3620 : 29c3                     and #$c3        ;mask NV----ZC
3622 : c511                     cmp adrf
                                trap_ne         ;bad flags
3624 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3626 : 28                       plp
3627 : 08                       php             ;save carry for next add
3628 : a50d                     lda ad1
362a : f158                     sbc (sbiy2),y   ;perform subtract
362c : 08                       php          
362d : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
362f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3631 : 68                       pla             ;check flags
3632 : 29c3                     and #$c3        ;mask NV----ZC
3634 : c511                     cmp adrf
                                trap_ne         ;bad flags
3636 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3638 : 28                       plp
3639 : 60                       rts
                        
                        ; target for the jump absolute test
363a : 88                       dey
363b : 88                       dey
363c :                  test_far
363c : 08                       php             ;either SP or Y count will fail, if we do not hit
363d : 88                       dey
363e : 88                       dey
363f : 88                       dey
3640 : 28                       plp
                                trap_cs         ;flags loaded?
3641 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3643 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3645 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3647 : f0fe            >        beq *           ;failed equal (zero)
                        
3649 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
364b : d0fe            >        bne *           ;failed not equal (non zero)
                        
364d : e041                     cpx #'A'
                                trap_ne        
364f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3651 : c04f                     cpy #('R'-3)
                                trap_ne
3653 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3655 : 48                       pha             ;save a,x
3656 : 8a                       txa
3657 : 48                       pha
3658 : ba                       tsx
3659 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
365b : d0fe            >        bne *           ;failed not equal (non zero)
                        
365d : 68                       pla             ;restore x
365e : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
365f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3661 : 48              >            pha         ;use stack to load status
3662 : 28              >            plp
                        
3663 : 68                       pla             ;restore a
3664 : e8                       inx             ;return registers with modifications
3665 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3667 : 4ce308                   jmp far_ret
                                
                        ; target for the jump indirect test
                                align
366a : 7336             ptr_tst_ind dw test_ind
366c : 3809             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
366e : 4c6e36          >        jmp *           ;failed anyway
                        
3671 : 88                       dey
3672 : 88                       dey
3673 :                  test_ind
3673 : 08                       php             ;either SP or Y count will fail, if we do not hit
3674 : 88                       dey
3675 : 88                       dey
3676 : 88                       dey
3677 : 28                       plp
                                trap_cs         ;flags loaded?
3678 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
367a : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
367c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
367e : f0fe            >        beq *           ;failed equal (zero)
                        
3680 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3682 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3684 : e04e                     cpx #'N'
                                trap_ne        
3686 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3688 : c041                     cpy #('D'-3)
                                trap_ne
368a : d0fe            >        bne *           ;failed not equal (non zero)
                        
368c : 48                       pha             ;save a,x
368d : 8a                       txa
368e : 48                       pha
368f : ba                       tsx
3690 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3692 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3694 : 68                       pla             ;restore x
3695 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3696 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3698 : 48              >            pha         ;use stack to load status
3699 : 28              >            plp
                        
369a : 68                       pla             ;restore a
369b : e8                       inx             ;return registers with modifications
369c : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
369e : 6c6c36                   jmp (ptr_ind_ret)
                                trap            ;runover protection
36a1 : 4ca136          >        jmp *           ;failed anyway
                        
                        
                        ; target for the jump subroutine test
36a4 : 88                       dey
36a5 : 88                       dey
36a6 :                  test_jsr
36a6 : 08                       php             ;either SP or Y count will fail, if we do not hit
36a7 : 88                       dey
36a8 : 88                       dey
36a9 : 88                       dey
36aa : 28                       plp
                                trap_cs         ;flags loaded?
36ab : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
36ad : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
36af : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
36b1 : f0fe            >        beq *           ;failed equal (zero)
                        
36b3 : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
36b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36b7 : e053                     cpx #'S'
                                trap_ne        
36b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36bb : c04f                     cpy #('R'-3)
                                trap_ne
36bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
36bf : 48                       pha             ;save a,x
36c0 : 8a                       txa
36c1 : 48                       pha       
36c2 : ba                       tsx             ;sp -4? (return addr,a,x)
36c3 : e0fb                     cpx #$fb
                                trap_ne
36c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36c7 : adff01                   lda $1ff        ;propper return on stack
36ca : c909                     cmp #hi(jsr_ret)
                                trap_ne
36cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ce : adfe01                   lda $1fe
36d1 : c96e                     cmp #lo(jsr_ret)
                                trap_ne
36d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
36d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
36d7 : 48              >            pha         ;use stack to load status
36d8 : 28              >            plp
                        
36d9 : 68                       pla             ;pull x,a
36da : aa                       tax
36db : 68                       pla
36dc : e8                       inx             ;return registers with modifications
36dd : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
36df : 60                       rts
                                trap            ;runover protection
36e0 : 4ce036          >        jmp *           ;failed anyway
                        
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
36e3 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
36e3 : 4ce336          >        jmp *           ;failed anyway
                        
36e6 :                  res_trap
                                trap            ;unexpected RESET
36e6 : 4ce636          >        jmp *           ;failed anyway
                        
                                
36e9 : 88                       dey
36ea : 88                       dey
36eb :                  irq_trap                ;BRK test or unextpected BRK or IRQ
36eb : 08                       php             ;either SP or Y count will fail, if we do not hit
36ec : 88                       dey
36ed : 88                       dey
36ee : 88                       dey
                                ;next 4 traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
36ef : c942                     cmp #'B'        ;registers loaded?
                                trap_ne
36f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36f3 : e052                     cpx #'R'
                                trap_ne        
36f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36f7 : c048                     cpy #('K'-3)
                                trap_ne
36f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36fb : 850a                     sta irq_a       ;save registers during break test
36fd : 860b                     stx irq_x
36ff : ba                       tsx             ;test break on stack
3700 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1
3703 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
3705 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3707 : 68                       pla
3708 : c934                     cmp #fai        ;should have added interrupt disable
                                trap_ne
370a : d0fe            >        bne *           ;failed not equal (non zero)
                        
370c : ba                       tsx
370d : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
370f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3711 : adff01                   lda $1ff        ;propper return on stack
3714 : c909                     cmp #hi(brk_ret)
                                trap_ne
3716 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3718 : adfe01                   lda $1fe
371b : c9a5                     cmp #lo(brk_ret)
                                trap_ne
371d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
371f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3721 : 48              >            pha         ;use stack to load status
3722 : 28              >            plp
                        
3723 : a60b                     ldx irq_x
3725 : e8                       inx             ;return registers with modifications
3726 : a50a                     lda irq_a
3728 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1 but original flags should be restored
372a : 40                       rti
                                trap            ;runover protection
372b : 4c2b37          >        jmp *           ;failed anyway
                        
                                
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
372e :                  zp_init
372e : c3824100         zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
3732 : 7f               zp7f_   db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
3733 : 001f7180         zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
3737 : 0fff7f80         zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
373b : ff0f8f8f         zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
373f : 0802             ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
3741 : 0902                     dw  abs1+1
3743 : 0a02                     dw  abs1+2
3745 : 0b02                     dw  abs1+3
3747 : 0c02                     dw  abs7f
3749 : 1001             inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
374b : 0302             indt_   dw  abst            ;indirect pointer to store area in absolute memory
374d : 0402                     dw  abst+1
374f : 0502                     dw  abst+2
3751 : 0602                     dw  abst+3
3753 : 0b01             inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
3755 : 3f02             indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
3757 : 4002                     dw  absAN+1
3759 : 4102                     dw  absAN+2
375b : 4202                     dw  absAN+3
375d : 4302             indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
375f : 4402                     dw  absEO+1
3761 : 4502                     dw  absEO+2
3763 : 4602                     dw  absEO+3
3765 : 3b02             indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
3767 : 3c02                     dw  absOR+1
3769 : 3d02                     dw  absOR+2
376b : 3e02                     dw  absOR+3
                        ;add/subtract indirect pointers
376d : 0302             adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
376f : 0402             sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
3771 : 0401             adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
3773 : 0501             sbiy2_  dw  sba2-$ff
3775 :                  zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
3775 :                  data_init
3775 : c3824100         abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
3779 : 7f               abs7f_  db  $7f             ;test pattern for compare
                        ;loads
377a : 80800002         fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
377e :                  rASL_                       ;expected result ASL & ROL -carry  
377e : 86048200         rROL_   db  $86,$04,$82,0   ; "
3782 : 87058301         rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
3786 :                  rLSR_                       ;expected result LSR & ROR -carry
3786 : 61412000         rROR_   db  $61,$41,$20,0   ; "
378a : e1c1a080         rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
378e :                  fASL_                       ;expected flags for shifts
378e : 81018002         fROL_   db  fnc,fc,fn,fz    ;no carry in
3792 : 81018000         fROLc_  db  fnc,fc,fn,0     ;carry in
3796 :                  fLSR_
3796 : 01000102         fROR_   db  fc,0,fc,fz      ;no carry in
379a : 81808180         fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
379e : 7f80ff0001       rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
37a3 : 0080800200       fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
37a8 : 001f7180         absOR_  db  0,$1f,$71,$80   ;test pattern for OR
37ac : 0fff7f80         absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
37b0 : ff0f8f8f         absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
37b4 : 00f11f00         absORa_ db  0,$f1,$1f,0     ;test pattern for OR
37b8 : f0ffffff         absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
37bc : fff0f00f         absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
37c0 : 00ff7f80         absrlo_ db  0,$ff,$7f,$80
37c4 : 02800080         absflo_ db  fz,fn,0,fn
37c8 :                  data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
37c8 :                  vec_init
37c8 : e336                     dw  nmi_trap
37ca : e636                     dw  res_trap
37cc : eb36                     dw  irq_trap
fffa =                  vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
                                org $fffa       ;vectors
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0400 through $37cd.
Total size 13262 bytes.
Program start address is at $0400 (1024).
